import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/runtime.js
var require_runtime = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/runtime.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = void 0;
    exports.BASE_PATH = "https://api.pinecone.io".replace(/\/+$/, "");
    var Configuration = (
      /** @class */
      function() {
        function Configuration2(configuration) {
          if (configuration === void 0) {
            configuration = {};
          }
          this.configuration = configuration;
        }
        Object.defineProperty(Configuration2.prototype, "config", {
          set: function(configuration) {
            this.configuration = configuration;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "basePath", {
          get: function() {
            return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "fetchApi", {
          get: function() {
            return this.configuration.fetchApi;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "middleware", {
          get: function() {
            return this.configuration.middleware || [];
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "queryParamsStringify", {
          get: function() {
            return this.configuration.queryParamsStringify || querystring;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "username", {
          get: function() {
            return this.configuration.username;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "password", {
          get: function() {
            return this.configuration.password;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "apiKey", {
          get: function() {
            var apiKey = this.configuration.apiKey;
            if (apiKey) {
              return typeof apiKey === "function" ? apiKey : function() {
                return apiKey;
              };
            }
            return void 0;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "accessToken", {
          get: function() {
            var _this = this;
            var accessToken = this.configuration.accessToken;
            if (accessToken) {
              return typeof accessToken === "function" ? accessToken : function() {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_a) {
                    return [2, accessToken];
                  });
                });
              };
            }
            return void 0;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "headers", {
          get: function() {
            return this.configuration.headers;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "credentials", {
          get: function() {
            return this.configuration.credentials;
          },
          enumerable: false,
          configurable: true
        });
        return Configuration2;
      }()
    );
    exports.Configuration = Configuration;
    exports.DefaultConfig = new Configuration();
    var BaseAPI = (
      /** @class */
      function() {
        function BaseAPI2(configuration) {
          if (configuration === void 0) {
            configuration = exports.DefaultConfig;
          }
          var _this = this;
          this.configuration = configuration;
          this.fetchApi = function(url, init) {
            return __awaiter(_this, void 0, void 0, function() {
              var fetchParams, _i, _a, middleware, response, e_1, _b, _c, middleware, _d, _e, middleware;
              return __generator(this, function(_f) {
                switch (_f.label) {
                  case 0:
                    fetchParams = { url, init };
                    _i = 0, _a = this.middleware;
                    _f.label = 1;
                  case 1:
                    if (!(_i < _a.length)) return [3, 4];
                    middleware = _a[_i];
                    if (!middleware.pre) return [3, 3];
                    return [4, middleware.pre(__assign({ fetch: this.fetchApi }, fetchParams))];
                  case 2:
                    fetchParams = _f.sent() || fetchParams;
                    _f.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    response = void 0;
                    _f.label = 5;
                  case 5:
                    _f.trys.push([5, 7, , 12]);
                    return [4, (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init)];
                  case 6:
                    response = _f.sent();
                    return [3, 12];
                  case 7:
                    e_1 = _f.sent();
                    _b = 0, _c = this.middleware;
                    _f.label = 8;
                  case 8:
                    if (!(_b < _c.length)) return [3, 11];
                    middleware = _c[_b];
                    if (!middleware.onError) return [3, 10];
                    return [4, middleware.onError({
                      fetch: this.fetchApi,
                      url: fetchParams.url,
                      init: fetchParams.init,
                      error: e_1,
                      response: response ? response.clone() : void 0
                    })];
                  case 9:
                    response = _f.sent() || response;
                    _f.label = 10;
                  case 10:
                    _b++;
                    return [3, 8];
                  case 11:
                    if (response === void 0) {
                      if (e_1 instanceof Error) {
                        throw new FetchError(e_1, "The request failed and the interceptors did not return an alternative response");
                      } else {
                        throw e_1;
                      }
                    }
                    return [3, 12];
                  case 12:
                    _d = 0, _e = this.middleware;
                    _f.label = 13;
                  case 13:
                    if (!(_d < _e.length)) return [3, 16];
                    middleware = _e[_d];
                    if (!middleware.post) return [3, 15];
                    return [4, middleware.post({
                      fetch: this.fetchApi,
                      url: fetchParams.url,
                      init: fetchParams.init,
                      response: response.clone()
                    })];
                  case 14:
                    response = _f.sent() || response;
                    _f.label = 15;
                  case 15:
                    _d++;
                    return [3, 13];
                  case 16:
                    return [2, response];
                }
              });
            });
          };
          this.middleware = configuration.middleware;
        }
        BaseAPI2.prototype.withMiddleware = function() {
          var _a;
          var middlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
          }
          var next = this.clone();
          next.middleware = (_a = next.middleware).concat.apply(_a, middlewares);
          return next;
        };
        BaseAPI2.prototype.withPreMiddleware = function() {
          var preMiddlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            preMiddlewares[_i] = arguments[_i];
          }
          var middlewares = preMiddlewares.map(function(pre) {
            return { pre };
          });
          return this.withMiddleware.apply(this, middlewares);
        };
        BaseAPI2.prototype.withPostMiddleware = function() {
          var postMiddlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            postMiddlewares[_i] = arguments[_i];
          }
          var middlewares = postMiddlewares.map(function(post) {
            return { post };
          });
          return this.withMiddleware.apply(this, middlewares);
        };
        BaseAPI2.prototype.isJsonMime = function(mime) {
          if (!mime) {
            return false;
          }
          return BaseAPI2.jsonRegex.test(mime);
        };
        BaseAPI2.prototype.request = function(context, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var _a, url, init, response;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this.createFetchParams(context, initOverrides)];
                case 1:
                  _a = _b.sent(), url = _a.url, init = _a.init;
                  return [4, this.fetchApi(url, init)];
                case 2:
                  response = _b.sent();
                  if (response && (response.status >= 200 && response.status < 300)) {
                    return [2, response];
                  }
                  throw new ResponseError(response, "Response returned an error code");
              }
            });
          });
        };
        BaseAPI2.prototype.createFetchParams = function(context, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var url, headers, initOverrideFn, initParams, overriddenInit, _a, body, init;
            var _this = this;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  url = this.configuration.basePath + context.path;
                  if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
                    url += "?" + this.configuration.queryParamsStringify(context.query);
                  }
                  headers = Object.assign({}, this.configuration.headers, context.headers);
                  Object.keys(headers).forEach(function(key) {
                    return headers[key] === void 0 ? delete headers[key] : {};
                  });
                  initOverrideFn = typeof initOverrides === "function" ? initOverrides : function() {
                    return __awaiter(_this, void 0, void 0, function() {
                      return __generator(this, function(_a2) {
                        return [2, initOverrides];
                      });
                    });
                  };
                  initParams = {
                    method: context.method,
                    headers,
                    body: context.body,
                    credentials: this.configuration.credentials
                  };
                  _a = [__assign({}, initParams)];
                  return [4, initOverrideFn({
                    init: initParams,
                    context
                  })];
                case 1:
                  overriddenInit = __assign.apply(void 0, _a.concat([_b.sent()]));
                  if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
                    body = overriddenInit.body;
                  } else if (this.isJsonMime(headers["Content-Type"])) {
                    body = JSON.stringify(overriddenInit.body);
                  } else {
                    body = overriddenInit.body;
                  }
                  init = __assign(__assign({}, overriddenInit), { body });
                  return [2, { url, init }];
              }
            });
          });
        };
        BaseAPI2.prototype.clone = function() {
          var constructor = this.constructor;
          var next = new constructor(this.configuration);
          next.middleware = this.middleware.slice();
          return next;
        };
        BaseAPI2.jsonRegex = new RegExp("^(:?application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(:?;.*)?$", "i");
        return BaseAPI2;
      }()
    );
    exports.BaseAPI = BaseAPI;
    function isBlob(value) {
      return typeof Blob !== "undefined" && value instanceof Blob;
    }
    function isFormData(value) {
      return typeof FormData !== "undefined" && value instanceof FormData;
    }
    var ResponseError = (
      /** @class */
      function(_super) {
        __extends(ResponseError2, _super);
        function ResponseError2(response, msg) {
          var _this = _super.call(this, msg) || this;
          _this.response = response;
          _this.name = "ResponseError";
          return _this;
        }
        return ResponseError2;
      }(Error)
    );
    exports.ResponseError = ResponseError;
    var FetchError = (
      /** @class */
      function(_super) {
        __extends(FetchError2, _super);
        function FetchError2(cause, msg) {
          var _this = _super.call(this, msg) || this;
          _this.cause = cause;
          _this.name = "FetchError";
          return _this;
        }
        return FetchError2;
      }(Error)
    );
    exports.FetchError = FetchError;
    var RequiredError = (
      /** @class */
      function(_super) {
        __extends(RequiredError2, _super);
        function RequiredError2(field, msg) {
          var _this = _super.call(this, msg) || this;
          _this.field = field;
          _this.name = "RequiredError";
          return _this;
        }
        return RequiredError2;
      }(Error)
    );
    exports.RequiredError = RequiredError;
    exports.COLLECTION_FORMATS = {
      csv: ",",
      ssv: " ",
      tsv: "	",
      pipes: "|"
    };
    function exists(json, key) {
      var value = json[key];
      return value !== null && value !== void 0;
    }
    exports.exists = exists;
    function querystring(params, prefix) {
      if (prefix === void 0) {
        prefix = "";
      }
      return Object.keys(params).map(function(key) {
        return querystringSingleKey(key, params[key], prefix);
      }).filter(function(part) {
        return part.length > 0;
      }).join("&");
    }
    exports.querystring = querystring;
    function querystringSingleKey(key, value, keyPrefix) {
      if (keyPrefix === void 0) {
        keyPrefix = "";
      }
      var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
      if (value instanceof Array) {
        var multiValue = value.map(function(singleValue) {
          return encodeURIComponent(String(singleValue));
        }).join("&".concat(encodeURIComponent(fullKey), "="));
        return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
      }
      if (value instanceof Set) {
        var valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
      }
      if (value instanceof Date) {
        return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
      }
      if (value instanceof Object) {
        return querystring(value, fullKey);
      }
      return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
    }
    function mapValues(data, fn) {
      return Object.keys(data).reduce(function(acc, key) {
        var _a;
        return __assign(__assign({}, acc), (_a = {}, _a[key] = fn(data[key]), _a));
      }, {});
    }
    exports.mapValues = mapValues;
    function canConsumeForm(consumes) {
      for (var _i = 0, consumes_1 = consumes; _i < consumes_1.length; _i++) {
        var consume = consumes_1[_i];
        if ("multipart/form-data" === consume.contentType) {
          return true;
        }
      }
      return false;
    }
    exports.canConsumeForm = canConsumeForm;
    var JSONApiResponse = (
      /** @class */
      function() {
        function JSONApiResponse2(raw, transformer) {
          if (transformer === void 0) {
            transformer = function(jsonValue) {
              return jsonValue;
            };
          }
          this.raw = raw;
          this.transformer = transformer;
        }
        JSONApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            var _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  _a = this.transformer;
                  return [4, this.raw.json()];
                case 1:
                  return [2, _a.apply(this, [_b.sent()])];
              }
            });
          });
        };
        return JSONApiResponse2;
      }()
    );
    exports.JSONApiResponse = JSONApiResponse;
    var VoidApiResponse = (
      /** @class */
      function() {
        function VoidApiResponse2(raw) {
          this.raw = raw;
        }
        VoidApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, void 0];
            });
          });
        };
        return VoidApiResponse2;
      }()
    );
    exports.VoidApiResponse = VoidApiResponse;
    var BlobApiResponse = (
      /** @class */
      function() {
        function BlobApiResponse2(raw) {
          this.raw = raw;
        }
        BlobApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.raw.blob()];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        ;
        return BlobApiResponse2;
      }()
    );
    exports.BlobApiResponse = BlobApiResponse;
    var TextApiResponse = (
      /** @class */
      function() {
        function TextApiResponse2(raw) {
          this.raw = raw;
        }
        TextApiResponse2.prototype.value = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.raw.text()];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        ;
        return TextApiResponse2;
      }()
    );
    exports.TextApiResponse = TextApiResponse;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CollectionModel.js
var require_CollectionModel = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CollectionModel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionModelToJSON = exports.CollectionModelFromJSONTyped = exports.CollectionModelFromJSON = exports.instanceOfCollectionModel = exports.CollectionModelStatusEnum = void 0;
    var runtime_1 = require_runtime();
    exports.CollectionModelStatusEnum = {
      Initializing: "Initializing",
      Ready: "Ready",
      Terminating: "Terminating"
    };
    function instanceOfCollectionModel(value) {
      var isInstance = true;
      isInstance = isInstance && "name" in value;
      isInstance = isInstance && "status" in value;
      isInstance = isInstance && "environment" in value;
      return isInstance;
    }
    exports.instanceOfCollectionModel = instanceOfCollectionModel;
    function CollectionModelFromJSON(json) {
      return CollectionModelFromJSONTyped(json, false);
    }
    exports.CollectionModelFromJSON = CollectionModelFromJSON;
    function CollectionModelFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": json["name"],
        "size": !(0, runtime_1.exists)(json, "size") ? void 0 : json["size"],
        "status": json["status"],
        "dimension": !(0, runtime_1.exists)(json, "dimension") ? void 0 : json["dimension"],
        "vectorCount": !(0, runtime_1.exists)(json, "vector_count") ? void 0 : json["vector_count"],
        "environment": json["environment"]
      };
    }
    exports.CollectionModelFromJSONTyped = CollectionModelFromJSONTyped;
    function CollectionModelToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "size": value.size,
        "status": value.status,
        "dimension": value.dimension,
        "vector_count": value.vectorCount,
        "environment": value.environment
      };
    }
    exports.CollectionModelToJSON = CollectionModelToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CollectionList.js
var require_CollectionList = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CollectionList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionListToJSON = exports.CollectionListFromJSONTyped = exports.CollectionListFromJSON = exports.instanceOfCollectionList = void 0;
    var runtime_1 = require_runtime();
    var CollectionModel_1 = require_CollectionModel();
    function instanceOfCollectionList(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfCollectionList = instanceOfCollectionList;
    function CollectionListFromJSON(json) {
      return CollectionListFromJSONTyped(json, false);
    }
    exports.CollectionListFromJSON = CollectionListFromJSON;
    function CollectionListFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "collections": !(0, runtime_1.exists)(json, "collections") ? void 0 : json["collections"].map(CollectionModel_1.CollectionModelFromJSON)
      };
    }
    exports.CollectionListFromJSONTyped = CollectionListFromJSONTyped;
    function CollectionListToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "collections": value.collections === void 0 ? void 0 : value.collections.map(CollectionModel_1.CollectionModelToJSON)
      };
    }
    exports.CollectionListToJSON = CollectionListToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ConfigureIndexRequestSpecPod.js
var require_ConfigureIndexRequestSpecPod = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ConfigureIndexRequestSpecPod.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigureIndexRequestSpecPodToJSON = exports.ConfigureIndexRequestSpecPodFromJSONTyped = exports.ConfigureIndexRequestSpecPodFromJSON = exports.instanceOfConfigureIndexRequestSpecPod = void 0;
    var runtime_1 = require_runtime();
    function instanceOfConfigureIndexRequestSpecPod(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfConfigureIndexRequestSpecPod = instanceOfConfigureIndexRequestSpecPod;
    function ConfigureIndexRequestSpecPodFromJSON(json) {
      return ConfigureIndexRequestSpecPodFromJSONTyped(json, false);
    }
    exports.ConfigureIndexRequestSpecPodFromJSON = ConfigureIndexRequestSpecPodFromJSON;
    function ConfigureIndexRequestSpecPodFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "podType": !(0, runtime_1.exists)(json, "pod_type") ? void 0 : json["pod_type"]
      };
    }
    exports.ConfigureIndexRequestSpecPodFromJSONTyped = ConfigureIndexRequestSpecPodFromJSONTyped;
    function ConfigureIndexRequestSpecPodToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "replicas": value.replicas,
        "pod_type": value.podType
      };
    }
    exports.ConfigureIndexRequestSpecPodToJSON = ConfigureIndexRequestSpecPodToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ConfigureIndexRequestSpec.js
var require_ConfigureIndexRequestSpec = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ConfigureIndexRequestSpec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigureIndexRequestSpecToJSON = exports.ConfigureIndexRequestSpecFromJSONTyped = exports.ConfigureIndexRequestSpecFromJSON = exports.instanceOfConfigureIndexRequestSpec = void 0;
    var ConfigureIndexRequestSpecPod_1 = require_ConfigureIndexRequestSpecPod();
    function instanceOfConfigureIndexRequestSpec(value) {
      var isInstance = true;
      isInstance = isInstance && "pod" in value;
      return isInstance;
    }
    exports.instanceOfConfigureIndexRequestSpec = instanceOfConfigureIndexRequestSpec;
    function ConfigureIndexRequestSpecFromJSON(json) {
      return ConfigureIndexRequestSpecFromJSONTyped(json, false);
    }
    exports.ConfigureIndexRequestSpecFromJSON = ConfigureIndexRequestSpecFromJSON;
    function ConfigureIndexRequestSpecFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "pod": (0, ConfigureIndexRequestSpecPod_1.ConfigureIndexRequestSpecPodFromJSON)(json["pod"])
      };
    }
    exports.ConfigureIndexRequestSpecFromJSONTyped = ConfigureIndexRequestSpecFromJSONTyped;
    function ConfigureIndexRequestSpecToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "pod": (0, ConfigureIndexRequestSpecPod_1.ConfigureIndexRequestSpecPodToJSON)(value.pod)
      };
    }
    exports.ConfigureIndexRequestSpecToJSON = ConfigureIndexRequestSpecToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ConfigureIndexRequest.js
var require_ConfigureIndexRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ConfigureIndexRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigureIndexRequestToJSON = exports.ConfigureIndexRequestFromJSONTyped = exports.ConfigureIndexRequestFromJSON = exports.instanceOfConfigureIndexRequest = void 0;
    var ConfigureIndexRequestSpec_1 = require_ConfigureIndexRequestSpec();
    function instanceOfConfigureIndexRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "spec" in value;
      return isInstance;
    }
    exports.instanceOfConfigureIndexRequest = instanceOfConfigureIndexRequest;
    function ConfigureIndexRequestFromJSON(json) {
      return ConfigureIndexRequestFromJSONTyped(json, false);
    }
    exports.ConfigureIndexRequestFromJSON = ConfigureIndexRequestFromJSON;
    function ConfigureIndexRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "spec": (0, ConfigureIndexRequestSpec_1.ConfigureIndexRequestSpecFromJSON)(json["spec"])
      };
    }
    exports.ConfigureIndexRequestFromJSONTyped = ConfigureIndexRequestFromJSONTyped;
    function ConfigureIndexRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "spec": (0, ConfigureIndexRequestSpec_1.ConfigureIndexRequestSpecToJSON)(value.spec)
      };
    }
    exports.ConfigureIndexRequestToJSON = ConfigureIndexRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateCollectionRequest.js
var require_CreateCollectionRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateCollectionRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateCollectionRequestToJSON = exports.CreateCollectionRequestFromJSONTyped = exports.CreateCollectionRequestFromJSON = exports.instanceOfCreateCollectionRequest = void 0;
    function instanceOfCreateCollectionRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "name" in value;
      isInstance = isInstance && "source" in value;
      return isInstance;
    }
    exports.instanceOfCreateCollectionRequest = instanceOfCreateCollectionRequest;
    function CreateCollectionRequestFromJSON(json) {
      return CreateCollectionRequestFromJSONTyped(json, false);
    }
    exports.CreateCollectionRequestFromJSON = CreateCollectionRequestFromJSON;
    function CreateCollectionRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": json["name"],
        "source": json["source"]
      };
    }
    exports.CreateCollectionRequestFromJSONTyped = CreateCollectionRequestFromJSONTyped;
    function CreateCollectionRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "source": value.source
      };
    }
    exports.CreateCollectionRequestToJSON = CreateCollectionRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateIndexRequestSpecPodMetadataConfig.js
var require_CreateIndexRequestSpecPodMetadataConfig = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateIndexRequestSpecPodMetadataConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateIndexRequestSpecPodMetadataConfigToJSON = exports.CreateIndexRequestSpecPodMetadataConfigFromJSONTyped = exports.CreateIndexRequestSpecPodMetadataConfigFromJSON = exports.instanceOfCreateIndexRequestSpecPodMetadataConfig = void 0;
    var runtime_1 = require_runtime();
    function instanceOfCreateIndexRequestSpecPodMetadataConfig(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfCreateIndexRequestSpecPodMetadataConfig = instanceOfCreateIndexRequestSpecPodMetadataConfig;
    function CreateIndexRequestSpecPodMetadataConfigFromJSON(json) {
      return CreateIndexRequestSpecPodMetadataConfigFromJSONTyped(json, false);
    }
    exports.CreateIndexRequestSpecPodMetadataConfigFromJSON = CreateIndexRequestSpecPodMetadataConfigFromJSON;
    function CreateIndexRequestSpecPodMetadataConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "indexed": !(0, runtime_1.exists)(json, "indexed") ? void 0 : json["indexed"]
      };
    }
    exports.CreateIndexRequestSpecPodMetadataConfigFromJSONTyped = CreateIndexRequestSpecPodMetadataConfigFromJSONTyped;
    function CreateIndexRequestSpecPodMetadataConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "indexed": value.indexed
      };
    }
    exports.CreateIndexRequestSpecPodMetadataConfigToJSON = CreateIndexRequestSpecPodMetadataConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateIndexRequestSpecPod.js
var require_CreateIndexRequestSpecPod = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateIndexRequestSpecPod.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateIndexRequestSpecPodToJSON = exports.CreateIndexRequestSpecPodFromJSONTyped = exports.CreateIndexRequestSpecPodFromJSON = exports.instanceOfCreateIndexRequestSpecPod = void 0;
    var runtime_1 = require_runtime();
    var CreateIndexRequestSpecPodMetadataConfig_1 = require_CreateIndexRequestSpecPodMetadataConfig();
    function instanceOfCreateIndexRequestSpecPod(value) {
      var isInstance = true;
      isInstance = isInstance && "environment" in value;
      isInstance = isInstance && "podType" in value;
      return isInstance;
    }
    exports.instanceOfCreateIndexRequestSpecPod = instanceOfCreateIndexRequestSpecPod;
    function CreateIndexRequestSpecPodFromJSON(json) {
      return CreateIndexRequestSpecPodFromJSONTyped(json, false);
    }
    exports.CreateIndexRequestSpecPodFromJSON = CreateIndexRequestSpecPodFromJSON;
    function CreateIndexRequestSpecPodFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "environment": json["environment"],
        "replicas": !(0, runtime_1.exists)(json, "replicas") ? void 0 : json["replicas"],
        "podType": json["pod_type"],
        "pods": !(0, runtime_1.exists)(json, "pods") ? void 0 : json["pods"],
        "shards": !(0, runtime_1.exists)(json, "shards") ? void 0 : json["shards"],
        "metadataConfig": !(0, runtime_1.exists)(json, "metadata_config") ? void 0 : (0, CreateIndexRequestSpecPodMetadataConfig_1.CreateIndexRequestSpecPodMetadataConfigFromJSON)(json["metadata_config"]),
        "sourceCollection": !(0, runtime_1.exists)(json, "source_collection") ? void 0 : json["source_collection"]
      };
    }
    exports.CreateIndexRequestSpecPodFromJSONTyped = CreateIndexRequestSpecPodFromJSONTyped;
    function CreateIndexRequestSpecPodToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "environment": value.environment,
        "replicas": value.replicas,
        "pod_type": value.podType,
        "pods": value.pods,
        "shards": value.shards,
        "metadata_config": (0, CreateIndexRequestSpecPodMetadataConfig_1.CreateIndexRequestSpecPodMetadataConfigToJSON)(value.metadataConfig),
        "source_collection": value.sourceCollection
      };
    }
    exports.CreateIndexRequestSpecPodToJSON = CreateIndexRequestSpecPodToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ServerlessSpec.js
var require_ServerlessSpec = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ServerlessSpec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServerlessSpecToJSON = exports.ServerlessSpecFromJSONTyped = exports.ServerlessSpecFromJSON = exports.instanceOfServerlessSpec = exports.ServerlessSpecCloudEnum = void 0;
    exports.ServerlessSpecCloudEnum = {
      Gcp: "gcp",
      Aws: "aws",
      Azure: "azure"
    };
    function instanceOfServerlessSpec(value) {
      var isInstance = true;
      isInstance = isInstance && "cloud" in value;
      isInstance = isInstance && "region" in value;
      return isInstance;
    }
    exports.instanceOfServerlessSpec = instanceOfServerlessSpec;
    function ServerlessSpecFromJSON(json) {
      return ServerlessSpecFromJSONTyped(json, false);
    }
    exports.ServerlessSpecFromJSON = ServerlessSpecFromJSON;
    function ServerlessSpecFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "cloud": json["cloud"],
        "region": json["region"]
      };
    }
    exports.ServerlessSpecFromJSONTyped = ServerlessSpecFromJSONTyped;
    function ServerlessSpecToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "cloud": value.cloud,
        "region": value.region
      };
    }
    exports.ServerlessSpecToJSON = ServerlessSpecToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateIndexRequestSpec.js
var require_CreateIndexRequestSpec = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateIndexRequestSpec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateIndexRequestSpecToJSON = exports.CreateIndexRequestSpecFromJSONTyped = exports.CreateIndexRequestSpecFromJSON = exports.instanceOfCreateIndexRequestSpec = void 0;
    var runtime_1 = require_runtime();
    var CreateIndexRequestSpecPod_1 = require_CreateIndexRequestSpecPod();
    var ServerlessSpec_1 = require_ServerlessSpec();
    function instanceOfCreateIndexRequestSpec(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfCreateIndexRequestSpec = instanceOfCreateIndexRequestSpec;
    function CreateIndexRequestSpecFromJSON(json) {
      return CreateIndexRequestSpecFromJSONTyped(json, false);
    }
    exports.CreateIndexRequestSpecFromJSON = CreateIndexRequestSpecFromJSON;
    function CreateIndexRequestSpecFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "serverless": !(0, runtime_1.exists)(json, "serverless") ? void 0 : (0, ServerlessSpec_1.ServerlessSpecFromJSON)(json["serverless"]),
        "pod": !(0, runtime_1.exists)(json, "pod") ? void 0 : (0, CreateIndexRequestSpecPod_1.CreateIndexRequestSpecPodFromJSON)(json["pod"])
      };
    }
    exports.CreateIndexRequestSpecFromJSONTyped = CreateIndexRequestSpecFromJSONTyped;
    function CreateIndexRequestSpecToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "serverless": (0, ServerlessSpec_1.ServerlessSpecToJSON)(value.serverless),
        "pod": (0, CreateIndexRequestSpecPod_1.CreateIndexRequestSpecPodToJSON)(value.pod)
      };
    }
    exports.CreateIndexRequestSpecToJSON = CreateIndexRequestSpecToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateIndexRequest.js
var require_CreateIndexRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/CreateIndexRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateIndexRequestToJSON = exports.CreateIndexRequestFromJSONTyped = exports.CreateIndexRequestFromJSON = exports.instanceOfCreateIndexRequest = exports.CreateIndexRequestMetricEnum = void 0;
    var runtime_1 = require_runtime();
    var CreateIndexRequestSpec_1 = require_CreateIndexRequestSpec();
    exports.CreateIndexRequestMetricEnum = {
      Cosine: "cosine",
      Euclidean: "euclidean",
      Dotproduct: "dotproduct"
    };
    function instanceOfCreateIndexRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "name" in value;
      isInstance = isInstance && "dimension" in value;
      isInstance = isInstance && "spec" in value;
      return isInstance;
    }
    exports.instanceOfCreateIndexRequest = instanceOfCreateIndexRequest;
    function CreateIndexRequestFromJSON(json) {
      return CreateIndexRequestFromJSONTyped(json, false);
    }
    exports.CreateIndexRequestFromJSON = CreateIndexRequestFromJSON;
    function CreateIndexRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": json["name"],
        "dimension": json["dimension"],
        "metric": !(0, runtime_1.exists)(json, "metric") ? void 0 : json["metric"],
        "spec": (0, CreateIndexRequestSpec_1.CreateIndexRequestSpecFromJSON)(json["spec"])
      };
    }
    exports.CreateIndexRequestFromJSONTyped = CreateIndexRequestFromJSONTyped;
    function CreateIndexRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "dimension": value.dimension,
        "metric": value.metric,
        "spec": (0, CreateIndexRequestSpec_1.CreateIndexRequestSpecToJSON)(value.spec)
      };
    }
    exports.CreateIndexRequestToJSON = CreateIndexRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DeleteRequest.js
var require_DeleteRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DeleteRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeleteRequestToJSON = exports.DeleteRequestFromJSONTyped = exports.DeleteRequestFromJSON = exports.instanceOfDeleteRequest = void 0;
    var runtime_1 = require_runtime();
    function instanceOfDeleteRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDeleteRequest = instanceOfDeleteRequest;
    function DeleteRequestFromJSON(json) {
      return DeleteRequestFromJSONTyped(json, false);
    }
    exports.DeleteRequestFromJSON = DeleteRequestFromJSON;
    function DeleteRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "ids": !(0, runtime_1.exists)(json, "ids") ? void 0 : json["ids"],
        "deleteAll": !(0, runtime_1.exists)(json, "deleteAll") ? void 0 : json["deleteAll"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.DeleteRequestFromJSONTyped = DeleteRequestFromJSONTyped;
    function DeleteRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ids": value.ids,
        "deleteAll": value.deleteAll,
        "namespace": value.namespace,
        "filter": value.filter
      };
    }
    exports.DeleteRequestToJSON = DeleteRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DescribeIndexStatsRequest.js
var require_DescribeIndexStatsRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DescribeIndexStatsRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DescribeIndexStatsRequestToJSON = exports.DescribeIndexStatsRequestFromJSONTyped = exports.DescribeIndexStatsRequestFromJSON = exports.instanceOfDescribeIndexStatsRequest = void 0;
    var runtime_1 = require_runtime();
    function instanceOfDescribeIndexStatsRequest(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDescribeIndexStatsRequest = instanceOfDescribeIndexStatsRequest;
    function DescribeIndexStatsRequestFromJSON(json) {
      return DescribeIndexStatsRequestFromJSONTyped(json, false);
    }
    exports.DescribeIndexStatsRequestFromJSON = DescribeIndexStatsRequestFromJSON;
    function DescribeIndexStatsRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.DescribeIndexStatsRequestFromJSONTyped = DescribeIndexStatsRequestFromJSONTyped;
    function DescribeIndexStatsRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "filter": value.filter
      };
    }
    exports.DescribeIndexStatsRequestToJSON = DescribeIndexStatsRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/NamespaceSummary.js
var require_NamespaceSummary = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/NamespaceSummary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NamespaceSummaryToJSON = exports.NamespaceSummaryFromJSONTyped = exports.NamespaceSummaryFromJSON = exports.instanceOfNamespaceSummary = void 0;
    var runtime_1 = require_runtime();
    function instanceOfNamespaceSummary(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfNamespaceSummary = instanceOfNamespaceSummary;
    function NamespaceSummaryFromJSON(json) {
      return NamespaceSummaryFromJSONTyped(json, false);
    }
    exports.NamespaceSummaryFromJSON = NamespaceSummaryFromJSON;
    function NamespaceSummaryFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectorCount": !(0, runtime_1.exists)(json, "vectorCount") ? void 0 : json["vectorCount"]
      };
    }
    exports.NamespaceSummaryFromJSONTyped = NamespaceSummaryFromJSONTyped;
    function NamespaceSummaryToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectorCount": value.vectorCount
      };
    }
    exports.NamespaceSummaryToJSON = NamespaceSummaryToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DescribeIndexStatsResponse.js
var require_DescribeIndexStatsResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/DescribeIndexStatsResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DescribeIndexStatsResponseToJSON = exports.DescribeIndexStatsResponseFromJSONTyped = exports.DescribeIndexStatsResponseFromJSON = exports.instanceOfDescribeIndexStatsResponse = void 0;
    var runtime_1 = require_runtime();
    var NamespaceSummary_1 = require_NamespaceSummary();
    function instanceOfDescribeIndexStatsResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfDescribeIndexStatsResponse = instanceOfDescribeIndexStatsResponse;
    function DescribeIndexStatsResponseFromJSON(json) {
      return DescribeIndexStatsResponseFromJSONTyped(json, false);
    }
    exports.DescribeIndexStatsResponseFromJSON = DescribeIndexStatsResponseFromJSON;
    function DescribeIndexStatsResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "namespaces": !(0, runtime_1.exists)(json, "namespaces") ? void 0 : (0, runtime_1.mapValues)(json["namespaces"], NamespaceSummary_1.NamespaceSummaryFromJSON),
        "dimension": !(0, runtime_1.exists)(json, "dimension") ? void 0 : json["dimension"],
        "indexFullness": !(0, runtime_1.exists)(json, "indexFullness") ? void 0 : json["indexFullness"],
        "totalVectorCount": !(0, runtime_1.exists)(json, "totalVectorCount") ? void 0 : json["totalVectorCount"]
      };
    }
    exports.DescribeIndexStatsResponseFromJSONTyped = DescribeIndexStatsResponseFromJSONTyped;
    function DescribeIndexStatsResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "namespaces": value.namespaces === void 0 ? void 0 : (0, runtime_1.mapValues)(value.namespaces, NamespaceSummary_1.NamespaceSummaryToJSON),
        "dimension": value.dimension,
        "indexFullness": value.indexFullness,
        "totalVectorCount": value.totalVectorCount
      };
    }
    exports.DescribeIndexStatsResponseToJSON = DescribeIndexStatsResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ErrorResponseError.js
var require_ErrorResponseError = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ErrorResponseError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorResponseErrorToJSON = exports.ErrorResponseErrorFromJSONTyped = exports.ErrorResponseErrorFromJSON = exports.instanceOfErrorResponseError = exports.ErrorResponseErrorCodeEnum = void 0;
    var runtime_1 = require_runtime();
    exports.ErrorResponseErrorCodeEnum = {
      Ok: "OK",
      Unknown: "UNKNOWN",
      InvalidArgument: "INVALID_ARGUMENT",
      DeadlineExceeded: "DEADLINE_EXCEEDED",
      QuotaExceeded: "QUOTA_EXCEEDED",
      NotFound: "NOT_FOUND",
      AlreadyExists: "ALREADY_EXISTS",
      PermissionDenied: "PERMISSION_DENIED",
      Unauthenticated: "UNAUTHENTICATED",
      ResourceExhausted: "RESOURCE_EXHAUSTED",
      FailedPrecondition: "FAILED_PRECONDITION",
      Aborted: "ABORTED",
      OutOfRange: "OUT_OF_RANGE",
      Unimplemented: "UNIMPLEMENTED",
      Internal: "INTERNAL",
      Unavailable: "UNAVAILABLE",
      DataLoss: "DATA_LOSS",
      Forbidden: "FORBIDDEN"
    };
    function instanceOfErrorResponseError(value) {
      var isInstance = true;
      isInstance = isInstance && "code" in value;
      isInstance = isInstance && "message" in value;
      return isInstance;
    }
    exports.instanceOfErrorResponseError = instanceOfErrorResponseError;
    function ErrorResponseErrorFromJSON(json) {
      return ErrorResponseErrorFromJSONTyped(json, false);
    }
    exports.ErrorResponseErrorFromJSON = ErrorResponseErrorFromJSON;
    function ErrorResponseErrorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "code": json["code"],
        "message": json["message"],
        "details": !(0, runtime_1.exists)(json, "details") ? void 0 : json["details"]
      };
    }
    exports.ErrorResponseErrorFromJSONTyped = ErrorResponseErrorFromJSONTyped;
    function ErrorResponseErrorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "code": value.code,
        "message": value.message,
        "details": value.details
      };
    }
    exports.ErrorResponseErrorToJSON = ErrorResponseErrorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ErrorResponse.js
var require_ErrorResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ErrorResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorResponseToJSON = exports.ErrorResponseFromJSONTyped = exports.ErrorResponseFromJSON = exports.instanceOfErrorResponse = void 0;
    var ErrorResponseError_1 = require_ErrorResponseError();
    function instanceOfErrorResponse(value) {
      var isInstance = true;
      isInstance = isInstance && "status" in value;
      isInstance = isInstance && "error" in value;
      return isInstance;
    }
    exports.instanceOfErrorResponse = instanceOfErrorResponse;
    function ErrorResponseFromJSON(json) {
      return ErrorResponseFromJSONTyped(json, false);
    }
    exports.ErrorResponseFromJSON = ErrorResponseFromJSON;
    function ErrorResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "status": json["status"],
        "error": (0, ErrorResponseError_1.ErrorResponseErrorFromJSON)(json["error"])
      };
    }
    exports.ErrorResponseFromJSONTyped = ErrorResponseFromJSONTyped;
    function ErrorResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "status": value.status,
        "error": (0, ErrorResponseError_1.ErrorResponseErrorToJSON)(value.error)
      };
    }
    exports.ErrorResponseToJSON = ErrorResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/Usage.js
var require_Usage = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/Usage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UsageToJSON = exports.UsageFromJSONTyped = exports.UsageFromJSON = exports.instanceOfUsage = void 0;
    var runtime_1 = require_runtime();
    function instanceOfUsage(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfUsage = instanceOfUsage;
    function UsageFromJSON(json) {
      return UsageFromJSONTyped(json, false);
    }
    exports.UsageFromJSON = UsageFromJSON;
    function UsageFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "readUnits": !(0, runtime_1.exists)(json, "readUnits") ? void 0 : json["readUnits"]
      };
    }
    exports.UsageFromJSONTyped = UsageFromJSONTyped;
    function UsageToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "readUnits": value.readUnits
      };
    }
    exports.UsageToJSON = UsageToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/SparseValues.js
var require_SparseValues = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/SparseValues.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SparseValuesToJSON = exports.SparseValuesFromJSONTyped = exports.SparseValuesFromJSON = exports.instanceOfSparseValues = void 0;
    function instanceOfSparseValues(value) {
      var isInstance = true;
      isInstance = isInstance && "indices" in value;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfSparseValues = instanceOfSparseValues;
    function SparseValuesFromJSON(json) {
      return SparseValuesFromJSONTyped(json, false);
    }
    exports.SparseValuesFromJSON = SparseValuesFromJSON;
    function SparseValuesFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "indices": json["indices"],
        "values": json["values"]
      };
    }
    exports.SparseValuesFromJSONTyped = SparseValuesFromJSONTyped;
    function SparseValuesToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "indices": value.indices,
        "values": value.values
      };
    }
    exports.SparseValuesToJSON = SparseValuesToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/Vector.js
var require_Vector = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/Vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VectorToJSON = exports.VectorFromJSONTyped = exports.VectorFromJSON = exports.instanceOfVector = void 0;
    var runtime_1 = require_runtime();
    var SparseValues_1 = require_SparseValues();
    function instanceOfVector(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfVector = instanceOfVector;
    function VectorFromJSON(json) {
      return VectorFromJSONTyped(json, false);
    }
    exports.VectorFromJSON = VectorFromJSON;
    function VectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "values": json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "metadata": !(0, runtime_1.exists)(json, "metadata") ? void 0 : json["metadata"]
      };
    }
    exports.VectorFromJSONTyped = VectorFromJSONTyped;
    function VectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "metadata": value.metadata
      };
    }
    exports.VectorToJSON = VectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/FetchResponse.js
var require_FetchResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/FetchResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchResponseToJSON = exports.FetchResponseFromJSONTyped = exports.FetchResponseFromJSON = exports.instanceOfFetchResponse = void 0;
    var runtime_1 = require_runtime();
    var Usage_1 = require_Usage();
    var Vector_1 = require_Vector();
    function instanceOfFetchResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfFetchResponse = instanceOfFetchResponse;
    function FetchResponseFromJSON(json) {
      return FetchResponseFromJSONTyped(json, false);
    }
    exports.FetchResponseFromJSON = FetchResponseFromJSON;
    function FetchResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectors": !(0, runtime_1.exists)(json, "vectors") ? void 0 : (0, runtime_1.mapValues)(json["vectors"], Vector_1.VectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "usage": !(0, runtime_1.exists)(json, "usage") ? void 0 : (0, Usage_1.UsageFromJSON)(json["usage"])
      };
    }
    exports.FetchResponseFromJSONTyped = FetchResponseFromJSONTyped;
    function FetchResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectors": value.vectors === void 0 ? void 0 : (0, runtime_1.mapValues)(value.vectors, Vector_1.VectorToJSON),
        "namespace": value.namespace,
        "usage": (0, Usage_1.UsageToJSON)(value.usage)
      };
    }
    exports.FetchResponseToJSON = FetchResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/PodSpecMetadataConfig.js
var require_PodSpecMetadataConfig = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/PodSpecMetadataConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PodSpecMetadataConfigToJSON = exports.PodSpecMetadataConfigFromJSONTyped = exports.PodSpecMetadataConfigFromJSON = exports.instanceOfPodSpecMetadataConfig = void 0;
    var runtime_1 = require_runtime();
    function instanceOfPodSpecMetadataConfig(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfPodSpecMetadataConfig = instanceOfPodSpecMetadataConfig;
    function PodSpecMetadataConfigFromJSON(json) {
      return PodSpecMetadataConfigFromJSONTyped(json, false);
    }
    exports.PodSpecMetadataConfigFromJSON = PodSpecMetadataConfigFromJSON;
    function PodSpecMetadataConfigFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "indexed": !(0, runtime_1.exists)(json, "indexed") ? void 0 : json["indexed"]
      };
    }
    exports.PodSpecMetadataConfigFromJSONTyped = PodSpecMetadataConfigFromJSONTyped;
    function PodSpecMetadataConfigToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "indexed": value.indexed
      };
    }
    exports.PodSpecMetadataConfigToJSON = PodSpecMetadataConfigToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/PodSpec.js
var require_PodSpec = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/PodSpec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PodSpecToJSON = exports.PodSpecFromJSONTyped = exports.PodSpecFromJSON = exports.instanceOfPodSpec = void 0;
    var runtime_1 = require_runtime();
    var PodSpecMetadataConfig_1 = require_PodSpecMetadataConfig();
    function instanceOfPodSpec(value) {
      var isInstance = true;
      isInstance = isInstance && "environment" in value;
      isInstance = isInstance && "replicas" in value;
      isInstance = isInstance && "shards" in value;
      isInstance = isInstance && "podType" in value;
      isInstance = isInstance && "pods" in value;
      return isInstance;
    }
    exports.instanceOfPodSpec = instanceOfPodSpec;
    function PodSpecFromJSON(json) {
      return PodSpecFromJSONTyped(json, false);
    }
    exports.PodSpecFromJSON = PodSpecFromJSON;
    function PodSpecFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "environment": json["environment"],
        "replicas": json["replicas"],
        "shards": json["shards"],
        "podType": json["pod_type"],
        "pods": json["pods"],
        "metadataConfig": !(0, runtime_1.exists)(json, "metadata_config") ? void 0 : (0, PodSpecMetadataConfig_1.PodSpecMetadataConfigFromJSON)(json["metadata_config"]),
        "sourceCollection": !(0, runtime_1.exists)(json, "source_collection") ? void 0 : json["source_collection"]
      };
    }
    exports.PodSpecFromJSONTyped = PodSpecFromJSONTyped;
    function PodSpecToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "environment": value.environment,
        "replicas": value.replicas,
        "shards": value.shards,
        "pod_type": value.podType,
        "pods": value.pods,
        "metadata_config": (0, PodSpecMetadataConfig_1.PodSpecMetadataConfigToJSON)(value.metadataConfig),
        "source_collection": value.sourceCollection
      };
    }
    exports.PodSpecToJSON = PodSpecToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexModelSpec.js
var require_IndexModelSpec = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexModelSpec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexModelSpecToJSON = exports.IndexModelSpecFromJSONTyped = exports.IndexModelSpecFromJSON = exports.instanceOfIndexModelSpec = void 0;
    var runtime_1 = require_runtime();
    var PodSpec_1 = require_PodSpec();
    var ServerlessSpec_1 = require_ServerlessSpec();
    function instanceOfIndexModelSpec(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexModelSpec = instanceOfIndexModelSpec;
    function IndexModelSpecFromJSON(json) {
      return IndexModelSpecFromJSONTyped(json, false);
    }
    exports.IndexModelSpecFromJSON = IndexModelSpecFromJSON;
    function IndexModelSpecFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "pod": !(0, runtime_1.exists)(json, "pod") ? void 0 : (0, PodSpec_1.PodSpecFromJSON)(json["pod"]),
        "serverless": !(0, runtime_1.exists)(json, "serverless") ? void 0 : (0, ServerlessSpec_1.ServerlessSpecFromJSON)(json["serverless"])
      };
    }
    exports.IndexModelSpecFromJSONTyped = IndexModelSpecFromJSONTyped;
    function IndexModelSpecToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "pod": (0, PodSpec_1.PodSpecToJSON)(value.pod),
        "serverless": (0, ServerlessSpec_1.ServerlessSpecToJSON)(value.serverless)
      };
    }
    exports.IndexModelSpecToJSON = IndexModelSpecToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexModelStatus.js
var require_IndexModelStatus = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexModelStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexModelStatusToJSON = exports.IndexModelStatusFromJSONTyped = exports.IndexModelStatusFromJSON = exports.instanceOfIndexModelStatus = exports.IndexModelStatusStateEnum = void 0;
    exports.IndexModelStatusStateEnum = {
      Initializing: "Initializing",
      InitializationFailed: "InitializationFailed",
      ScalingUp: "ScalingUp",
      ScalingDown: "ScalingDown",
      ScalingUpPodSize: "ScalingUpPodSize",
      ScalingDownPodSize: "ScalingDownPodSize",
      Terminating: "Terminating",
      Ready: "Ready"
    };
    function instanceOfIndexModelStatus(value) {
      var isInstance = true;
      isInstance = isInstance && "ready" in value;
      isInstance = isInstance && "state" in value;
      return isInstance;
    }
    exports.instanceOfIndexModelStatus = instanceOfIndexModelStatus;
    function IndexModelStatusFromJSON(json) {
      return IndexModelStatusFromJSONTyped(json, false);
    }
    exports.IndexModelStatusFromJSON = IndexModelStatusFromJSON;
    function IndexModelStatusFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "ready": json["ready"],
        "state": json["state"]
      };
    }
    exports.IndexModelStatusFromJSONTyped = IndexModelStatusFromJSONTyped;
    function IndexModelStatusToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "ready": value.ready,
        "state": value.state
      };
    }
    exports.IndexModelStatusToJSON = IndexModelStatusToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexModel.js
var require_IndexModel = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexModel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexModelToJSON = exports.IndexModelFromJSONTyped = exports.IndexModelFromJSON = exports.instanceOfIndexModel = exports.IndexModelMetricEnum = void 0;
    var IndexModelSpec_1 = require_IndexModelSpec();
    var IndexModelStatus_1 = require_IndexModelStatus();
    exports.IndexModelMetricEnum = {
      Cosine: "cosine",
      Euclidean: "euclidean",
      Dotproduct: "dotproduct"
    };
    function instanceOfIndexModel(value) {
      var isInstance = true;
      isInstance = isInstance && "name" in value;
      isInstance = isInstance && "dimension" in value;
      isInstance = isInstance && "metric" in value;
      isInstance = isInstance && "host" in value;
      isInstance = isInstance && "spec" in value;
      isInstance = isInstance && "status" in value;
      return isInstance;
    }
    exports.instanceOfIndexModel = instanceOfIndexModel;
    function IndexModelFromJSON(json) {
      return IndexModelFromJSONTyped(json, false);
    }
    exports.IndexModelFromJSON = IndexModelFromJSON;
    function IndexModelFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "name": json["name"],
        "dimension": json["dimension"],
        "metric": json["metric"],
        "host": json["host"],
        "spec": (0, IndexModelSpec_1.IndexModelSpecFromJSON)(json["spec"]),
        "status": (0, IndexModelStatus_1.IndexModelStatusFromJSON)(json["status"])
      };
    }
    exports.IndexModelFromJSONTyped = IndexModelFromJSONTyped;
    function IndexModelToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "name": value.name,
        "dimension": value.dimension,
        "metric": value.metric,
        "host": value.host,
        "spec": (0, IndexModelSpec_1.IndexModelSpecToJSON)(value.spec),
        "status": (0, IndexModelStatus_1.IndexModelStatusToJSON)(value.status)
      };
    }
    exports.IndexModelToJSON = IndexModelToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexList.js
var require_IndexList = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/IndexList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexListToJSON = exports.IndexListFromJSONTyped = exports.IndexListFromJSON = exports.instanceOfIndexList = void 0;
    var runtime_1 = require_runtime();
    var IndexModel_1 = require_IndexModel();
    function instanceOfIndexList(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfIndexList = instanceOfIndexList;
    function IndexListFromJSON(json) {
      return IndexListFromJSONTyped(json, false);
    }
    exports.IndexListFromJSON = IndexListFromJSON;
    function IndexListFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "indexes": !(0, runtime_1.exists)(json, "indexes") ? void 0 : json["indexes"].map(IndexModel_1.IndexModelFromJSON)
      };
    }
    exports.IndexListFromJSONTyped = IndexListFromJSONTyped;
    function IndexListToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "indexes": value.indexes === void 0 ? void 0 : value.indexes.map(IndexModel_1.IndexModelToJSON)
      };
    }
    exports.IndexListToJSON = IndexListToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ListItem.js
var require_ListItem = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ListItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListItemToJSON = exports.ListItemFromJSONTyped = exports.ListItemFromJSON = exports.instanceOfListItem = void 0;
    var runtime_1 = require_runtime();
    function instanceOfListItem(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfListItem = instanceOfListItem;
    function ListItemFromJSON(json) {
      return ListItemFromJSONTyped(json, false);
    }
    exports.ListItemFromJSON = ListItemFromJSON;
    function ListItemFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": !(0, runtime_1.exists)(json, "id") ? void 0 : json["id"]
      };
    }
    exports.ListItemFromJSONTyped = ListItemFromJSONTyped;
    function ListItemToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id
      };
    }
    exports.ListItemToJSON = ListItemToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/Pagination.js
var require_Pagination = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/Pagination.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PaginationToJSON = exports.PaginationFromJSONTyped = exports.PaginationFromJSON = exports.instanceOfPagination = void 0;
    var runtime_1 = require_runtime();
    function instanceOfPagination(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfPagination = instanceOfPagination;
    function PaginationFromJSON(json) {
      return PaginationFromJSONTyped(json, false);
    }
    exports.PaginationFromJSON = PaginationFromJSON;
    function PaginationFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "next": !(0, runtime_1.exists)(json, "next") ? void 0 : json["next"]
      };
    }
    exports.PaginationFromJSONTyped = PaginationFromJSONTyped;
    function PaginationToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "next": value.next
      };
    }
    exports.PaginationToJSON = PaginationToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ListResponse.js
var require_ListResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ListResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListResponseToJSON = exports.ListResponseFromJSONTyped = exports.ListResponseFromJSON = exports.instanceOfListResponse = void 0;
    var runtime_1 = require_runtime();
    var ListItem_1 = require_ListItem();
    var Pagination_1 = require_Pagination();
    var Usage_1 = require_Usage();
    function instanceOfListResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfListResponse = instanceOfListResponse;
    function ListResponseFromJSON(json) {
      return ListResponseFromJSONTyped(json, false);
    }
    exports.ListResponseFromJSON = ListResponseFromJSON;
    function ListResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectors": !(0, runtime_1.exists)(json, "vectors") ? void 0 : json["vectors"].map(ListItem_1.ListItemFromJSON),
        "pagination": !(0, runtime_1.exists)(json, "pagination") ? void 0 : (0, Pagination_1.PaginationFromJSON)(json["pagination"]),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "usage": !(0, runtime_1.exists)(json, "usage") ? void 0 : (0, Usage_1.UsageFromJSON)(json["usage"])
      };
    }
    exports.ListResponseFromJSONTyped = ListResponseFromJSONTyped;
    function ListResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectors": value.vectors === void 0 ? void 0 : value.vectors.map(ListItem_1.ListItemToJSON),
        "pagination": (0, Pagination_1.PaginationToJSON)(value.pagination),
        "namespace": value.namespace,
        "usage": (0, Usage_1.UsageToJSON)(value.usage)
      };
    }
    exports.ListResponseToJSON = ListResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ProtobufAny.js
var require_ProtobufAny = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ProtobufAny.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtobufAnyToJSON = exports.ProtobufAnyFromJSONTyped = exports.ProtobufAnyFromJSON = exports.instanceOfProtobufAny = void 0;
    var runtime_1 = require_runtime();
    function instanceOfProtobufAny(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfProtobufAny = instanceOfProtobufAny;
    function ProtobufAnyFromJSON(json) {
      return ProtobufAnyFromJSONTyped(json, false);
    }
    exports.ProtobufAnyFromJSON = ProtobufAnyFromJSON;
    function ProtobufAnyFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "typeUrl": !(0, runtime_1.exists)(json, "typeUrl") ? void 0 : json["typeUrl"],
        "value": !(0, runtime_1.exists)(json, "value") ? void 0 : json["value"]
      };
    }
    exports.ProtobufAnyFromJSONTyped = ProtobufAnyFromJSONTyped;
    function ProtobufAnyToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "typeUrl": value.typeUrl,
        "value": value.value
      };
    }
    exports.ProtobufAnyToJSON = ProtobufAnyToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ProtobufNullValue.js
var require_ProtobufNullValue = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ProtobufNullValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtobufNullValueToJSON = exports.ProtobufNullValueFromJSONTyped = exports.ProtobufNullValueFromJSON = exports.ProtobufNullValue = void 0;
    exports.ProtobufNullValue = {
      NullValue: "NULL_VALUE"
    };
    function ProtobufNullValueFromJSON(json) {
      return ProtobufNullValueFromJSONTyped(json, false);
    }
    exports.ProtobufNullValueFromJSON = ProtobufNullValueFromJSON;
    function ProtobufNullValueFromJSONTyped(json, ignoreDiscriminator) {
      return json;
    }
    exports.ProtobufNullValueFromJSONTyped = ProtobufNullValueFromJSONTyped;
    function ProtobufNullValueToJSON(value) {
      return value;
    }
    exports.ProtobufNullValueToJSON = ProtobufNullValueToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryVector.js
var require_QueryVector = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryVector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryVectorToJSON = exports.QueryVectorFromJSONTyped = exports.QueryVectorFromJSON = exports.instanceOfQueryVector = void 0;
    var runtime_1 = require_runtime();
    var SparseValues_1 = require_SparseValues();
    function instanceOfQueryVector(value) {
      var isInstance = true;
      isInstance = isInstance && "values" in value;
      return isInstance;
    }
    exports.instanceOfQueryVector = instanceOfQueryVector;
    function QueryVectorFromJSON(json) {
      return QueryVectorFromJSONTyped(json, false);
    }
    exports.QueryVectorFromJSON = QueryVectorFromJSON;
    function QueryVectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "values": json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "topK": !(0, runtime_1.exists)(json, "topK") ? void 0 : json["topK"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"]
      };
    }
    exports.QueryVectorFromJSONTyped = QueryVectorFromJSONTyped;
    function QueryVectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "topK": value.topK,
        "namespace": value.namespace,
        "filter": value.filter
      };
    }
    exports.QueryVectorToJSON = QueryVectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryRequest.js
var require_QueryRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryRequestToJSON = exports.QueryRequestFromJSONTyped = exports.QueryRequestFromJSON = exports.instanceOfQueryRequest = void 0;
    var runtime_1 = require_runtime();
    var QueryVector_1 = require_QueryVector();
    var SparseValues_1 = require_SparseValues();
    function instanceOfQueryRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "topK" in value;
      return isInstance;
    }
    exports.instanceOfQueryRequest = instanceOfQueryRequest;
    function QueryRequestFromJSON(json) {
      return QueryRequestFromJSONTyped(json, false);
    }
    exports.QueryRequestFromJSON = QueryRequestFromJSON;
    function QueryRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "topK": json["topK"],
        "filter": !(0, runtime_1.exists)(json, "filter") ? void 0 : json["filter"],
        "includeValues": !(0, runtime_1.exists)(json, "includeValues") ? void 0 : json["includeValues"],
        "includeMetadata": !(0, runtime_1.exists)(json, "includeMetadata") ? void 0 : json["includeMetadata"],
        "queries": !(0, runtime_1.exists)(json, "queries") ? void 0 : json["queries"].map(QueryVector_1.QueryVectorFromJSON),
        "vector": !(0, runtime_1.exists)(json, "vector") ? void 0 : json["vector"],
        "sparseVector": !(0, runtime_1.exists)(json, "sparseVector") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseVector"]),
        "id": !(0, runtime_1.exists)(json, "id") ? void 0 : json["id"]
      };
    }
    exports.QueryRequestFromJSONTyped = QueryRequestFromJSONTyped;
    function QueryRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "namespace": value.namespace,
        "topK": value.topK,
        "filter": value.filter,
        "includeValues": value.includeValues,
        "includeMetadata": value.includeMetadata,
        "queries": value.queries === void 0 ? void 0 : value.queries.map(QueryVector_1.QueryVectorToJSON),
        "vector": value.vector,
        "sparseVector": (0, SparseValues_1.SparseValuesToJSON)(value.sparseVector),
        "id": value.id
      };
    }
    exports.QueryRequestToJSON = QueryRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ScoredVector.js
var require_ScoredVector = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/ScoredVector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScoredVectorToJSON = exports.ScoredVectorFromJSONTyped = exports.ScoredVectorFromJSON = exports.instanceOfScoredVector = void 0;
    var runtime_1 = require_runtime();
    var SparseValues_1 = require_SparseValues();
    function instanceOfScoredVector(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      return isInstance;
    }
    exports.instanceOfScoredVector = instanceOfScoredVector;
    function ScoredVectorFromJSON(json) {
      return ScoredVectorFromJSONTyped(json, false);
    }
    exports.ScoredVectorFromJSON = ScoredVectorFromJSON;
    function ScoredVectorFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "score": !(0, runtime_1.exists)(json, "score") ? void 0 : json["score"],
        "values": !(0, runtime_1.exists)(json, "values") ? void 0 : json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "metadata": !(0, runtime_1.exists)(json, "metadata") ? void 0 : json["metadata"]
      };
    }
    exports.ScoredVectorFromJSONTyped = ScoredVectorFromJSONTyped;
    function ScoredVectorToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "score": value.score,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "metadata": value.metadata
      };
    }
    exports.ScoredVectorToJSON = ScoredVectorToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/SingleQueryResults.js
var require_SingleQueryResults = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/SingleQueryResults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleQueryResultsToJSON = exports.SingleQueryResultsFromJSONTyped = exports.SingleQueryResultsFromJSON = exports.instanceOfSingleQueryResults = void 0;
    var runtime_1 = require_runtime();
    var ScoredVector_1 = require_ScoredVector();
    function instanceOfSingleQueryResults(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfSingleQueryResults = instanceOfSingleQueryResults;
    function SingleQueryResultsFromJSON(json) {
      return SingleQueryResultsFromJSONTyped(json, false);
    }
    exports.SingleQueryResultsFromJSON = SingleQueryResultsFromJSON;
    function SingleQueryResultsFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "matches": !(0, runtime_1.exists)(json, "matches") ? void 0 : json["matches"].map(ScoredVector_1.ScoredVectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.SingleQueryResultsFromJSONTyped = SingleQueryResultsFromJSONTyped;
    function SingleQueryResultsToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "matches": value.matches === void 0 ? void 0 : value.matches.map(ScoredVector_1.ScoredVectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.SingleQueryResultsToJSON = SingleQueryResultsToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryResponse.js
var require_QueryResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/QueryResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryResponseToJSON = exports.QueryResponseFromJSONTyped = exports.QueryResponseFromJSON = exports.instanceOfQueryResponse = void 0;
    var runtime_1 = require_runtime();
    var ScoredVector_1 = require_ScoredVector();
    var SingleQueryResults_1 = require_SingleQueryResults();
    var Usage_1 = require_Usage();
    function instanceOfQueryResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfQueryResponse = instanceOfQueryResponse;
    function QueryResponseFromJSON(json) {
      return QueryResponseFromJSONTyped(json, false);
    }
    exports.QueryResponseFromJSON = QueryResponseFromJSON;
    function QueryResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "results": !(0, runtime_1.exists)(json, "results") ? void 0 : json["results"].map(SingleQueryResults_1.SingleQueryResultsFromJSON),
        "matches": !(0, runtime_1.exists)(json, "matches") ? void 0 : json["matches"].map(ScoredVector_1.ScoredVectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"],
        "usage": !(0, runtime_1.exists)(json, "usage") ? void 0 : (0, Usage_1.UsageFromJSON)(json["usage"])
      };
    }
    exports.QueryResponseFromJSONTyped = QueryResponseFromJSONTyped;
    function QueryResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "results": value.results === void 0 ? void 0 : value.results.map(SingleQueryResults_1.SingleQueryResultsToJSON),
        "matches": value.matches === void 0 ? void 0 : value.matches.map(ScoredVector_1.ScoredVectorToJSON),
        "namespace": value.namespace,
        "usage": (0, Usage_1.UsageToJSON)(value.usage)
      };
    }
    exports.QueryResponseToJSON = QueryResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/RpcStatus.js
var require_RpcStatus = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/RpcStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RpcStatusToJSON = exports.RpcStatusFromJSONTyped = exports.RpcStatusFromJSON = exports.instanceOfRpcStatus = void 0;
    var runtime_1 = require_runtime();
    var ProtobufAny_1 = require_ProtobufAny();
    function instanceOfRpcStatus(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfRpcStatus = instanceOfRpcStatus;
    function RpcStatusFromJSON(json) {
      return RpcStatusFromJSONTyped(json, false);
    }
    exports.RpcStatusFromJSON = RpcStatusFromJSON;
    function RpcStatusFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "code": !(0, runtime_1.exists)(json, "code") ? void 0 : json["code"],
        "message": !(0, runtime_1.exists)(json, "message") ? void 0 : json["message"],
        "details": !(0, runtime_1.exists)(json, "details") ? void 0 : json["details"].map(ProtobufAny_1.ProtobufAnyFromJSON)
      };
    }
    exports.RpcStatusFromJSONTyped = RpcStatusFromJSONTyped;
    function RpcStatusToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "code": value.code,
        "message": value.message,
        "details": value.details === void 0 ? void 0 : value.details.map(ProtobufAny_1.ProtobufAnyToJSON)
      };
    }
    exports.RpcStatusToJSON = RpcStatusToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpdateRequest.js
var require_UpdateRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpdateRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateRequestToJSON = exports.UpdateRequestFromJSONTyped = exports.UpdateRequestFromJSON = exports.instanceOfUpdateRequest = void 0;
    var runtime_1 = require_runtime();
    var SparseValues_1 = require_SparseValues();
    function instanceOfUpdateRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "id" in value;
      return isInstance;
    }
    exports.instanceOfUpdateRequest = instanceOfUpdateRequest;
    function UpdateRequestFromJSON(json) {
      return UpdateRequestFromJSONTyped(json, false);
    }
    exports.UpdateRequestFromJSON = UpdateRequestFromJSON;
    function UpdateRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "id": json["id"],
        "values": !(0, runtime_1.exists)(json, "values") ? void 0 : json["values"],
        "sparseValues": !(0, runtime_1.exists)(json, "sparseValues") ? void 0 : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
        "setMetadata": !(0, runtime_1.exists)(json, "setMetadata") ? void 0 : json["setMetadata"],
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.UpdateRequestFromJSONTyped = UpdateRequestFromJSONTyped;
    function UpdateRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "id": value.id,
        "values": value.values,
        "sparseValues": (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        "setMetadata": value.setMetadata,
        "namespace": value.namespace
      };
    }
    exports.UpdateRequestToJSON = UpdateRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpsertRequest.js
var require_UpsertRequest = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpsertRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertRequestToJSON = exports.UpsertRequestFromJSONTyped = exports.UpsertRequestFromJSON = exports.instanceOfUpsertRequest = void 0;
    var runtime_1 = require_runtime();
    var Vector_1 = require_Vector();
    function instanceOfUpsertRequest(value) {
      var isInstance = true;
      isInstance = isInstance && "vectors" in value;
      return isInstance;
    }
    exports.instanceOfUpsertRequest = instanceOfUpsertRequest;
    function UpsertRequestFromJSON(json) {
      return UpsertRequestFromJSONTyped(json, false);
    }
    exports.UpsertRequestFromJSON = UpsertRequestFromJSON;
    function UpsertRequestFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "vectors": json["vectors"].map(Vector_1.VectorFromJSON),
        "namespace": !(0, runtime_1.exists)(json, "namespace") ? void 0 : json["namespace"]
      };
    }
    exports.UpsertRequestFromJSONTyped = UpsertRequestFromJSONTyped;
    function UpsertRequestToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "vectors": value.vectors.map(Vector_1.VectorToJSON),
        "namespace": value.namespace
      };
    }
    exports.UpsertRequestToJSON = UpsertRequestToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpsertResponse.js
var require_UpsertResponse = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/UpsertResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertResponseToJSON = exports.UpsertResponseFromJSONTyped = exports.UpsertResponseFromJSON = exports.instanceOfUpsertResponse = void 0;
    var runtime_1 = require_runtime();
    function instanceOfUpsertResponse(value) {
      var isInstance = true;
      return isInstance;
    }
    exports.instanceOfUpsertResponse = instanceOfUpsertResponse;
    function UpsertResponseFromJSON(json) {
      return UpsertResponseFromJSONTyped(json, false);
    }
    exports.UpsertResponseFromJSON = UpsertResponseFromJSON;
    function UpsertResponseFromJSONTyped(json, ignoreDiscriminator) {
      if (json === void 0 || json === null) {
        return json;
      }
      return {
        "upsertedCount": !(0, runtime_1.exists)(json, "upsertedCount") ? void 0 : json["upsertedCount"]
      };
    }
    exports.UpsertResponseFromJSONTyped = UpsertResponseFromJSONTyped;
    function UpsertResponseToJSON(value) {
      if (value === void 0) {
        return void 0;
      }
      if (value === null) {
        return null;
      }
      return {
        "upsertedCount": value.upsertedCount
      };
    }
    exports.UpsertResponseToJSON = UpsertResponseToJSON;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/index.js
var require_models = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/models/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_CollectionList(), exports);
    __exportStar(require_CollectionModel(), exports);
    __exportStar(require_ConfigureIndexRequest(), exports);
    __exportStar(require_ConfigureIndexRequestSpec(), exports);
    __exportStar(require_ConfigureIndexRequestSpecPod(), exports);
    __exportStar(require_CreateCollectionRequest(), exports);
    __exportStar(require_CreateIndexRequest(), exports);
    __exportStar(require_CreateIndexRequestSpec(), exports);
    __exportStar(require_CreateIndexRequestSpecPod(), exports);
    __exportStar(require_CreateIndexRequestSpecPodMetadataConfig(), exports);
    __exportStar(require_DeleteRequest(), exports);
    __exportStar(require_DescribeIndexStatsRequest(), exports);
    __exportStar(require_DescribeIndexStatsResponse(), exports);
    __exportStar(require_ErrorResponse(), exports);
    __exportStar(require_ErrorResponseError(), exports);
    __exportStar(require_FetchResponse(), exports);
    __exportStar(require_IndexList(), exports);
    __exportStar(require_IndexModel(), exports);
    __exportStar(require_IndexModelSpec(), exports);
    __exportStar(require_IndexModelStatus(), exports);
    __exportStar(require_ListItem(), exports);
    __exportStar(require_ListResponse(), exports);
    __exportStar(require_NamespaceSummary(), exports);
    __exportStar(require_Pagination(), exports);
    __exportStar(require_PodSpec(), exports);
    __exportStar(require_PodSpecMetadataConfig(), exports);
    __exportStar(require_ProtobufAny(), exports);
    __exportStar(require_ProtobufNullValue(), exports);
    __exportStar(require_QueryRequest(), exports);
    __exportStar(require_QueryResponse(), exports);
    __exportStar(require_QueryVector(), exports);
    __exportStar(require_RpcStatus(), exports);
    __exportStar(require_ScoredVector(), exports);
    __exportStar(require_ServerlessSpec(), exports);
    __exportStar(require_SingleQueryResults(), exports);
    __exportStar(require_SparseValues(), exports);
    __exportStar(require_UpdateRequest(), exports);
    __exportStar(require_UpsertRequest(), exports);
    __exportStar(require_UpsertResponse(), exports);
    __exportStar(require_Usage(), exports);
    __exportStar(require_Vector(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/DataPlaneApi.js
var require_DataPlaneApi = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/DataPlaneApi.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataPlaneApi = void 0;
    var runtime = __importStar(require_runtime());
    var index_1 = require_models();
    var DataPlaneApi = (
      /** @class */
      function(_super) {
        __extends(DataPlaneApi2, _super);
        function DataPlaneApi2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        DataPlaneApi2.prototype._deleteRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.deleteRequest === null || requestParameters.deleteRequest === void 0) {
                    throw new runtime.RequiredError("deleteRequest", "Required parameter requestParameters.deleteRequest was null or undefined when calling _delete.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/delete",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.DeleteRequestToJSON)(requestParameters.deleteRequest)
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        DataPlaneApi2.prototype._delete = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this._deleteRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        DataPlaneApi2.prototype.altDeleteRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  queryParameters = {};
                  if (requestParameters.ids) {
                    queryParameters["ids"] = requestParameters.ids;
                  }
                  if (requestParameters.deleteAll !== void 0) {
                    queryParameters["deleteAll"] = requestParameters.deleteAll;
                  }
                  if (requestParameters.namespace !== void 0) {
                    queryParameters["namespace"] = requestParameters.namespace;
                  }
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/delete",
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        DataPlaneApi2.prototype.altDelete = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.altDeleteRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        DataPlaneApi2.prototype.altDescribeIndexStatsRaw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/describe_index_stats",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.DescribeIndexStatsResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        DataPlaneApi2.prototype.altDescribeIndexStats = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.altDescribeIndexStatsRaw(initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        DataPlaneApi2.prototype.describeIndexStatsRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.describeIndexStatsRequest === null || requestParameters.describeIndexStatsRequest === void 0) {
                    throw new runtime.RequiredError("describeIndexStatsRequest", "Required parameter requestParameters.describeIndexStatsRequest was null or undefined when calling describeIndexStats.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/describe_index_stats",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.DescribeIndexStatsRequestToJSON)(requestParameters.describeIndexStatsRequest)
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.DescribeIndexStatsResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        DataPlaneApi2.prototype.describeIndexStats = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.describeIndexStatsRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        DataPlaneApi2.prototype.fetchRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.ids === null || requestParameters.ids === void 0) {
                    throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling fetch.");
                  }
                  queryParameters = {};
                  if (requestParameters.ids) {
                    queryParameters["ids"] = requestParameters.ids;
                  }
                  if (requestParameters.namespace !== void 0) {
                    queryParameters["namespace"] = requestParameters.namespace;
                  }
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/fetch",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.FetchResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        DataPlaneApi2.prototype.fetch = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fetchRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        DataPlaneApi2.prototype.listRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  queryParameters = {};
                  if (requestParameters.prefix !== void 0) {
                    queryParameters["prefix"] = requestParameters.prefix;
                  }
                  if (requestParameters.limit !== void 0) {
                    queryParameters["limit"] = requestParameters.limit;
                  }
                  if (requestParameters.paginationToken !== void 0) {
                    queryParameters["paginationToken"] = requestParameters.paginationToken;
                  }
                  if (requestParameters.namespace !== void 0) {
                    queryParameters["namespace"] = requestParameters.namespace;
                  }
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/list",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.ListResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        DataPlaneApi2.prototype.list = function(requestParameters, initOverrides) {
          if (requestParameters === void 0) {
            requestParameters = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.listRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        DataPlaneApi2.prototype.queryRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.queryRequest === null || requestParameters.queryRequest === void 0) {
                    throw new runtime.RequiredError("queryRequest", "Required parameter requestParameters.queryRequest was null or undefined when calling query.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/query",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.QueryRequestToJSON)(requestParameters.queryRequest)
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.QueryResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        DataPlaneApi2.prototype.query = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.queryRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        DataPlaneApi2.prototype.updateRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.updateRequest === null || requestParameters.updateRequest === void 0) {
                    throw new runtime.RequiredError("updateRequest", "Required parameter requestParameters.updateRequest was null or undefined when calling update.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/update",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.UpdateRequestToJSON)(requestParameters.updateRequest)
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response)];
              }
            });
          });
        };
        DataPlaneApi2.prototype.update = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.updateRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        DataPlaneApi2.prototype.upsertRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.upsertRequest === null || requestParameters.upsertRequest === void 0) {
                    throw new runtime.RequiredError("upsertRequest", "Required parameter requestParameters.upsertRequest was null or undefined when calling upsert.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/vectors/upsert",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.UpsertRequestToJSON)(requestParameters.upsertRequest)
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.UpsertResponseFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        DataPlaneApi2.prototype.upsert = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.upsertRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        return DataPlaneApi2;
      }(runtime.BaseAPI)
    );
    exports.DataPlaneApi = DataPlaneApi;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/ManageIndexesApi.js
var require_ManageIndexesApi = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/ManageIndexesApi.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ManageIndexesApi = void 0;
    var runtime = __importStar(require_runtime());
    var index_1 = require_models();
    var ManageIndexesApi = (
      /** @class */
      function(_super) {
        __extends(ManageIndexesApi2, _super);
        function ManageIndexesApi2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        ManageIndexesApi2.prototype.configureIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling configureIndex.");
                  }
                  if (requestParameters.configureIndexRequest === null || requestParameters.configureIndexRequest === void 0) {
                    throw new runtime.RequiredError("configureIndexRequest", "Required parameter requestParameters.configureIndexRequest was null or undefined when calling configureIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/indexes/{index_name}".replace("{".concat("index_name", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "PATCH",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.ConfigureIndexRequestToJSON)(requestParameters.configureIndexRequest)
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.IndexModelFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.configureIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.configureIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.createCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.createCollectionRequest === null || requestParameters.createCollectionRequest === void 0) {
                    throw new runtime.RequiredError("createCollectionRequest", "Required parameter requestParameters.createCollectionRequest was null or undefined when calling createCollection.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.CreateCollectionRequestToJSON)(requestParameters.createCollectionRequest)
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.CollectionModelFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.createCollection = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.createCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.createIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.createIndexRequest === null || requestParameters.createIndexRequest === void 0) {
                    throw new runtime.RequiredError("createIndexRequest", "Required parameter requestParameters.createIndexRequest was null or undefined when calling createIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  headerParameters["Content-Type"] = "application/json";
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/indexes",
                    method: "POST",
                    headers: headerParameters,
                    query: queryParameters,
                    body: (0, index_1.CreateIndexRequestToJSON)(requestParameters.createIndexRequest)
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.IndexModelFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.createIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.createIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.deleteCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.collectionName === null || requestParameters.collectionName === void 0) {
                    throw new runtime.RequiredError("collectionName", "Required parameter requestParameters.collectionName was null or undefined when calling deleteCollection.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections/{collection_name}".replace("{".concat("collection_name", "}"), encodeURIComponent(String(requestParameters.collectionName))),
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  if (this.isJsonMime(response.headers.get("content-type"))) {
                    return [2, new runtime.JSONApiResponse(response)];
                  } else {
                    return [2, new runtime.TextApiResponse(response)];
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.deleteCollection = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.deleteCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.deleteIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling deleteIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/indexes/{index_name}".replace("{".concat("index_name", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "DELETE",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.VoidApiResponse(response)];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.deleteIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.deleteIndexRaw(requestParameters, initOverrides)];
                case 1:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.describeCollectionRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.collectionName === null || requestParameters.collectionName === void 0) {
                    throw new runtime.RequiredError("collectionName", "Required parameter requestParameters.collectionName was null or undefined when calling describeCollection.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections/{collection_name}".replace("{".concat("collection_name", "}"), encodeURIComponent(String(requestParameters.collectionName))),
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.CollectionModelFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.describeCollection = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.describeCollectionRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.describeIndexRaw = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (requestParameters.indexName === null || requestParameters.indexName === void 0) {
                    throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling describeIndex.");
                  }
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/indexes/{index_name}".replace("{".concat("index_name", "}"), encodeURIComponent(String(requestParameters.indexName))),
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.IndexModelFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.describeIndex = function(requestParameters, initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.describeIndexRaw(requestParameters, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.listCollectionsRaw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/collections",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.CollectionListFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.listCollections = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.listCollectionsRaw(initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.listIndexesRaw = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var queryParameters, headerParameters, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  queryParameters = {};
                  headerParameters = {};
                  if (this.configuration && this.configuration.apiKey) {
                    headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
                  }
                  return [4, this.request({
                    path: "/indexes",
                    method: "GET",
                    headers: headerParameters,
                    query: queryParameters
                  }, initOverrides)];
                case 1:
                  response = _a.sent();
                  return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                    return (0, index_1.IndexListFromJSON)(jsonValue);
                  })];
              }
            });
          });
        };
        ManageIndexesApi2.prototype.listIndexes = function(initOverrides) {
          return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.listIndexesRaw(initOverrides)];
                case 1:
                  response = _a.sent();
                  return [4, response.value()];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        return ManageIndexesApi2;
      }(runtime.BaseAPI)
    );
    exports.ManageIndexesApi = ManageIndexesApi;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/index.js
var require_apis = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/apis/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_DataPlaneApi(), exports);
    __exportStar(require_ManageIndexesApi(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/index.js
var require_pinecone_generated_ts_fetch = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_runtime(), exports);
    __exportStar(require_apis(), exports);
    __exportStar(require_models(), exports);
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/debugLog.js
var require_debugLog = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/debugLog.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debugLog = void 0;
    var debugLog = function(str) {
      if (typeof process !== "undefined" && process && process.env && process.env.PINECONE_DEBUG) {
        console.log(str);
      }
    };
    exports.debugLog = debugLog;
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/normalizeUrl.js
var require_normalizeUrl = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/normalizeUrl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeUrl = void 0;
    function normalizeUrl(url) {
      if (!url || url.trim().length === 0) {
        return;
      }
      if (!url.startsWith("http://") && !url.startsWith("https://")) {
        return "https://" + url;
      }
      return url;
    }
    exports.normalizeUrl = normalizeUrl;
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/queryParamsStringify.js
var require_queryParamsStringify = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/queryParamsStringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.queryParamsStringify = void 0;
    function queryParamsStringify(params, prefix) {
      if (prefix === void 0) {
        prefix = "";
      }
      return Object.keys(params).map(function(key) {
        return querystringSingleKey(key, params[key], prefix);
      }).filter(function(part) {
        return part.length > 0;
      }).join("&");
    }
    exports.queryParamsStringify = queryParamsStringify;
    function querystringSingleKey(key, value, keyPrefix) {
      if (keyPrefix === void 0) {
        keyPrefix = "";
      }
      var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
      if (Array.isArray(value)) {
        var multiValue = value.map(function(singleValue) {
          return encodeURIComponent(String(singleValue));
        }).join("&".concat(encodeURIComponent(fullKey), "="));
        return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
      }
      if (value instanceof Set) {
        var valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
      }
      if (value instanceof Date) {
        return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
      }
      if (value instanceof Object) {
        return queryParamsStringify(value, fullKey);
      }
      return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
    }
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/environment.js
var require_environment = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEdge = void 0;
    var isEdge = function() {
      return typeof EdgeRuntime === "string";
    };
    exports.isEdge = isEdge;
  }
});

// node_modules/@pinecone-database/pinecone/dist/version.json
var require_version = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/version.json"(exports, module) {
    module.exports = {
      name: "@pinecone-database/pinecone",
      version: "2.2.1"
    };
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/user-agent.js
var require_user_agent = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/user-agent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildUserAgent = void 0;
    var environment_1 = require_environment();
    var packageInfo = __importStar(require_version());
    var buildUserAgent = function(config) {
      var userAgentParts = [
        "".concat(packageInfo.name, " v").concat(packageInfo.version),
        "lang=typescript"
      ];
      if ((0, environment_1.isEdge)()) {
        userAgentParts.push("Edge Runtime");
      }
      if (typeof process !== "undefined" && process && process.version) {
        userAgentParts.push("node ".concat(process.version));
      }
      if (config.sourceTag) {
        userAgentParts.push("source_tag=".concat(normalizeSourceTag(config.sourceTag)));
      }
      return userAgentParts.join("; ");
    };
    exports.buildUserAgent = buildUserAgent;
    var normalizeSourceTag = function(sourceTag) {
      if (!sourceTag) {
        return;
      }
      return sourceTag.toLowerCase().replace(/[^a-z0-9_ ]/g, "").trim().replace(/[ ]+/g, "_");
    };
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var g = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g,
          iterable: "Symbol" in g && "iterator" in Symbol,
          blob: "FileReader" in g && "Blob" in g && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in g,
          arrayBuffer: "ArrayBuffer" in g
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g.location.href ? g.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g.fetch) {
          g.fetch = fetch2;
          g.Headers = Headers;
          g.Request = Request;
          g.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/fetch.js
var require_fetch = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/fetch.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFetch = void 0;
    var cross_fetch_1 = __importDefault(require_browser_ponyfill());
    var getFetch = function(config) {
      if (config.fetchApi) {
        return config.fetchApi;
      } else if (global.fetch) {
        return global.fetch;
      } else {
        return cross_fetch_1.default;
      }
    };
    exports.getFetch = getFetch;
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/index.js
var require_utils = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFetch = exports.buildUserAgent = exports.queryParamsStringify = exports.normalizeUrl = exports.debugLog = void 0;
    var debugLog_1 = require_debugLog();
    Object.defineProperty(exports, "debugLog", { enumerable: true, get: function() {
      return debugLog_1.debugLog;
    } });
    var normalizeUrl_1 = require_normalizeUrl();
    Object.defineProperty(exports, "normalizeUrl", { enumerable: true, get: function() {
      return normalizeUrl_1.normalizeUrl;
    } });
    var queryParamsStringify_1 = require_queryParamsStringify();
    Object.defineProperty(exports, "queryParamsStringify", { enumerable: true, get: function() {
      return queryParamsStringify_1.queryParamsStringify;
    } });
    var user_agent_1 = require_user_agent();
    Object.defineProperty(exports, "buildUserAgent", { enumerable: true, get: function() {
      return user_agent_1.buildUserAgent;
    } });
    var fetch_1 = require_fetch();
    Object.defineProperty(exports, "getFetch", { enumerable: true, get: function() {
      return fetch_1.getFetch;
    } });
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/base.js
var require_base = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/base.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasePineconeError = void 0;
    var BasePineconeError = (
      /** @class */
      function(_super) {
        __extends(BasePineconeError2, _super);
        function BasePineconeError2(message, cause) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, message) || this;
          Object.setPrototypeOf(_this, _newTarget.prototype);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _newTarget);
          }
          _this.name = _this.constructor.name;
          _this.cause = cause;
          return _this;
        }
        return BasePineconeError2;
      }(Error)
    );
    exports.BasePineconeError = BasePineconeError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/config.js
var require_config = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/config.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeUnableToResolveHostError = exports.PineconeEnvironmentVarsNotSupportedError = exports.PineconeUnexpectedResponseError = exports.PineconeConfigurationError = void 0;
    var base_1 = require_base();
    var CONFIG_HELP = "You can find the configuration values for your project in the Pinecone developer console at https://app.pinecone.io";
    var PineconeConfigurationError = (
      /** @class */
      function(_super) {
        __extends(PineconeConfigurationError2, _super);
        function PineconeConfigurationError2(message) {
          var _this = _super.call(this, "".concat(message, " ").concat(CONFIG_HELP)) || this;
          _this.name = "PineconeConfigurationError";
          return _this;
        }
        return PineconeConfigurationError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeConfigurationError = PineconeConfigurationError;
    var PineconeUnexpectedResponseError = (
      /** @class */
      function(_super) {
        __extends(PineconeUnexpectedResponseError2, _super);
        function PineconeUnexpectedResponseError2(url, status, body, message) {
          var _this = _super.call(this, "Unexpected response while calling ".concat(url, ". ").concat(message ? message + " " : "", "Status: ").concat(status, ". Body: ").concat(body)) || this;
          _this.name = "PineconeUnexpectedResponseError";
          return _this;
        }
        return PineconeUnexpectedResponseError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeUnexpectedResponseError = PineconeUnexpectedResponseError;
    var PineconeEnvironmentVarsNotSupportedError = (
      /** @class */
      function(_super) {
        __extends(PineconeEnvironmentVarsNotSupportedError2, _super);
        function PineconeEnvironmentVarsNotSupportedError2(message) {
          var _this = _super.call(this, message) || this;
          _this.name = "PineconeEnvironmentVarsNotSupportedError";
          return _this;
        }
        return PineconeEnvironmentVarsNotSupportedError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeEnvironmentVarsNotSupportedError = PineconeEnvironmentVarsNotSupportedError;
    var PineconeUnableToResolveHostError = (
      /** @class */
      function(_super) {
        __extends(PineconeUnableToResolveHostError2, _super);
        function PineconeUnableToResolveHostError2(message) {
          var _this = _super.call(this, message) || this;
          _this.name = "PineconeUnableToResolveHostError";
          return _this;
        }
        return PineconeUnableToResolveHostError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeUnableToResolveHostError = PineconeUnableToResolveHostError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/http.js
var require_http = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/http.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapHttpStatusError = exports.PineconeUnmappedHttpError = exports.PineconeNotImplementedError = exports.PineconeInternalServerError = exports.PineconeConflictError = exports.PineconeNotFoundError = exports.PineconeAuthorizationError = exports.PineconeBadRequestError = void 0;
    var base_1 = require_base();
    var CONFIG_HELP = "You can find the configuration values for your project in the Pinecone developer console at https://app.pinecone.io";
    var PineconeBadRequestError = (
      /** @class */
      function(_super) {
        __extends(PineconeBadRequestError2, _super);
        function PineconeBadRequestError2(failedRequest) {
          var _this = this;
          var message = failedRequest.message;
          _this = _super.call(this, message) || this;
          _this.name = "PineconeBadRequestError";
          return _this;
        }
        return PineconeBadRequestError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeBadRequestError = PineconeBadRequestError;
    var PineconeAuthorizationError = (
      /** @class */
      function(_super) {
        __extends(PineconeAuthorizationError2, _super);
        function PineconeAuthorizationError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url;
          if (url) {
            _this = _super.call(this, "The API key you provided was rejected while calling ".concat(url, ". Please check your configuration values and try again. ").concat(CONFIG_HELP)) || this;
          } else {
            _this = _super.call(this, "The API key you provided was rejected. Please check your configuration values and try again. ".concat(CONFIG_HELP)) || this;
          }
          _this.name = "PineconeAuthorizationError";
          return _this;
        }
        return PineconeAuthorizationError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeAuthorizationError = PineconeAuthorizationError;
    var PineconeNotFoundError = (
      /** @class */
      function(_super) {
        __extends(PineconeNotFoundError2, _super);
        function PineconeNotFoundError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url;
          if (url) {
            _this = _super.call(this, "A call to ".concat(url, " returned HTTP status 404.")) || this;
          } else {
            _this = _super.call(this, "The requested resource could not be found.") || this;
          }
          _this.name = "PineconeNotFoundError";
          return _this;
        }
        return PineconeNotFoundError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeNotFoundError = PineconeNotFoundError;
    var PineconeConflictError = (
      /** @class */
      function(_super) {
        __extends(PineconeConflictError2, _super);
        function PineconeConflictError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url, message = failedRequest.message;
          if (url) {
            _this = _super.call(this, "A call to ".concat(url, " returned HTTP status 409. ").concat(message ? message : "")) || this;
          } else {
            _this = _super.call(this, "The resource you are attempting to create already exists.") || this;
          }
          _this.name = "PineconeConflictError";
          return _this;
        }
        return PineconeConflictError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeConflictError = PineconeConflictError;
    var PineconeInternalServerError = (
      /** @class */
      function(_super) {
        __extends(PineconeInternalServerError2, _super);
        function PineconeInternalServerError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url, body = failedRequest.body;
          var intro = url ? "An internal server error occured while calling the ".concat(url, " endpoint.") : "";
          var help = "To see overall service health and learn whether this seems like a large-scale problem or one specific to your request, please go to https://status.pinecone.io/ to view our status page. If you believe the error reflects a problem with this client, please file a bug report in the github issue tracker at https://github.com/pinecone-io/pinecone-ts-client";
          var bodyMessage = body ? "Body: ".concat(body) : "";
          _this = _super.call(this, [intro, help, bodyMessage].join(" ").trim()) || this;
          _this.name = "PineconeInternalServerError";
          return _this;
        }
        return PineconeInternalServerError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeInternalServerError = PineconeInternalServerError;
    var PineconeNotImplementedError = (
      /** @class */
      function(_super) {
        __extends(PineconeNotImplementedError2, _super);
        function PineconeNotImplementedError2(requestInfo) {
          var _this = this;
          var url = requestInfo.url, message = requestInfo.message;
          if (url) {
            _this = _super.call(this, "A call to ".concat(url, " returned HTTP status 501. ").concat(message ? message : "")) || this;
          } else {
            _this = _super.call(this) || this;
          }
          _this.name = "PineconeNotImplementedError";
          return _this;
        }
        return PineconeNotImplementedError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeNotImplementedError = PineconeNotImplementedError;
    var PineconeUnmappedHttpError = (
      /** @class */
      function(_super) {
        __extends(PineconeUnmappedHttpError2, _super);
        function PineconeUnmappedHttpError2(failedRequest) {
          var _this = this;
          var url = failedRequest.url, status = failedRequest.status, body = failedRequest.body, message = failedRequest.message;
          var intro = url ? "An unexpected error occured while calling the ".concat(url, " endpoint. ") : "";
          var statusMsg = status ? "Status: ".concat(status, ". ") : "";
          var bodyMsg = body ? "Body: ".concat(body) : "";
          _this = _super.call(this, [intro, message, statusMsg, bodyMsg].join(" ").trim()) || this;
          _this.name = "PineconeUnmappedHttpError";
          return _this;
        }
        return PineconeUnmappedHttpError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeUnmappedHttpError = PineconeUnmappedHttpError;
    var mapHttpStatusError = function(failedRequestInfo) {
      switch (failedRequestInfo.status) {
        case 400:
          return new PineconeBadRequestError(failedRequestInfo);
        case 401:
          return new PineconeAuthorizationError(failedRequestInfo);
        case 404:
          return new PineconeNotFoundError(failedRequestInfo);
        case 409:
          return new PineconeConflictError(failedRequestInfo);
        case 500:
          return new PineconeInternalServerError(failedRequestInfo);
        case 501:
          return new PineconeNotImplementedError(failedRequestInfo);
        default:
          throw new PineconeUnmappedHttpError(failedRequestInfo);
      }
    };
    exports.mapHttpStatusError = mapHttpStatusError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/request.js
var require_request = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/request.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeRequestError = exports.PineconeConnectionError = void 0;
    var base_1 = require_base();
    var PineconeConnectionError = (
      /** @class */
      function(_super) {
        __extends(PineconeConnectionError2, _super);
        function PineconeConnectionError2(e, url) {
          var _this = this;
          var urlMessage = "";
          if (url) {
            urlMessage = " while calling ".concat(url);
          }
          _this = _super.call(this, "Request failed to reach Pinecone".concat(urlMessage, ". This can occur for reasons such as network problems that prevent the request from being completed, or a Pinecone API outage. Check your network connection, and visit https://status.pinecone.io/ to see whether any outages are ongoing."), e) || this;
          _this.name = "PineconeConnectionError";
          return _this;
        }
        return PineconeConnectionError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeConnectionError = PineconeConnectionError;
    var PineconeRequestError = (
      /** @class */
      function(_super) {
        __extends(PineconeRequestError2, _super);
        function PineconeRequestError2(context) {
          var _this = this;
          if (context.response) {
            _this = _super.call(this, "Request failed during a call to ".concat(context.init.method, " ").concat(context.url, " with status ").concat(context.response.status), context.error) || this;
          } else {
            _this = _super.call(this, "Request failed during a call to ".concat(context.init.method, " ").concat(context.url), context.error) || this;
          }
          return _this;
        }
        return PineconeRequestError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeRequestError = PineconeRequestError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/validation.js
var require_validation = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/validation.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeArgumentError = void 0;
    var base_1 = require_base();
    var PineconeArgumentError = (
      /** @class */
      function(_super) {
        __extends(PineconeArgumentError2, _super);
        function PineconeArgumentError2(message) {
          var _this = _super.call(this, "".concat(message)) || this;
          _this.name = "PineconeArgumentError";
          return _this;
        }
        return PineconeArgumentError2;
      }(base_1.BasePineconeError)
    );
    exports.PineconeArgumentError = PineconeArgumentError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/utils.js
var require_utils2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/utils.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractMessage = void 0;
    var extractMessage = function(error) {
      return __awaiter(void 0, void 0, void 0, function() {
        var message, messageJSON;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, error.response.text()];
            case 1:
              message = _a.sent();
              try {
                messageJSON = JSON.parse(message);
                if (messageJSON.message) {
                  message = messageJSON.message;
                }
              } catch (e) {
              }
              return [2, message];
          }
        });
      });
    };
    exports.extractMessage = extractMessage;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/handling.js
var require_handling = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/handling.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleApiError = void 0;
    var utils_1 = require_utils2();
    var http_1 = require_http();
    var request_1 = require_request();
    var handleApiError = function(e, customMessage, url) {
      return __awaiter(void 0, void 0, void 0, function() {
        var responseError, rawMessage, statusCode, message, _a, err;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!(e instanceof Error && e.name === "ResponseError")) return [3, 5];
              responseError = e;
              return [4, (0, utils_1.extractMessage)(responseError)];
            case 1:
              rawMessage = _b.sent();
              statusCode = responseError.response.status;
              if (!customMessage) return [3, 3];
              return [4, customMessage(statusCode, rawMessage)];
            case 2:
              _a = _b.sent();
              return [3, 4];
            case 3:
              _a = rawMessage;
              _b.label = 4;
            case 4:
              message = _a;
              return [2, (0, http_1.mapHttpStatusError)({
                status: responseError.response.status,
                url: responseError.response.url || url,
                message
              })];
            case 5:
              if (e instanceof request_1.PineconeConnectionError) {
                return [2, e];
              } else {
                err = e;
                return [2, new request_1.PineconeConnectionError(err)];
              }
              _b.label = 6;
            case 6:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.handleApiError = handleApiError;
  }
});

// node_modules/@pinecone-database/pinecone/dist/errors/index.js
var require_errors = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleApiError = exports.extractMessage = exports.PineconeArgumentError = exports.BasePineconeError = exports.PineconeRequestError = exports.PineconeConnectionError = exports.PineconeUnableToResolveHostError = exports.PineconeEnvironmentVarsNotSupportedError = exports.PineconeUnexpectedResponseError = exports.PineconeConfigurationError = void 0;
    var config_1 = require_config();
    Object.defineProperty(exports, "PineconeConfigurationError", { enumerable: true, get: function() {
      return config_1.PineconeConfigurationError;
    } });
    Object.defineProperty(exports, "PineconeUnexpectedResponseError", { enumerable: true, get: function() {
      return config_1.PineconeUnexpectedResponseError;
    } });
    Object.defineProperty(exports, "PineconeEnvironmentVarsNotSupportedError", { enumerable: true, get: function() {
      return config_1.PineconeEnvironmentVarsNotSupportedError;
    } });
    Object.defineProperty(exports, "PineconeUnableToResolveHostError", { enumerable: true, get: function() {
      return config_1.PineconeUnableToResolveHostError;
    } });
    __exportStar(require_http(), exports);
    var request_1 = require_request();
    Object.defineProperty(exports, "PineconeConnectionError", { enumerable: true, get: function() {
      return request_1.PineconeConnectionError;
    } });
    Object.defineProperty(exports, "PineconeRequestError", { enumerable: true, get: function() {
      return request_1.PineconeRequestError;
    } });
    var base_1 = require_base();
    Object.defineProperty(exports, "BasePineconeError", { enumerable: true, get: function() {
      return base_1.BasePineconeError;
    } });
    var validation_1 = require_validation();
    Object.defineProperty(exports, "PineconeArgumentError", { enumerable: true, get: function() {
      return validation_1.PineconeArgumentError;
    } });
    var utils_1 = require_utils2();
    Object.defineProperty(exports, "extractMessage", { enumerable: true, get: function() {
      return utils_1.extractMessage;
    } });
    var handling_1 = require_handling();
    Object.defineProperty(exports, "handleApiError", { enumerable: true, get: function() {
      return handling_1.handleApiError;
    } });
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/middleware.js
var require_middleware = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/utils/middleware.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.middleware = void 0;
    var pinecone_generated_ts_fetch_1 = require_pinecone_generated_ts_fetch();
    var errors_1 = require_errors();
    var debugMiddleware = [];
    var chalk = function(str, color) {
      var colors = {
        blue: "\x1B[34m",
        red: "\x1B[31m",
        green: "\x1B[32m",
        yellow: "\x1B[33m"
      };
      return colors[color] + str + "\x1B[39m";
    };
    if (typeof process !== "undefined" && process && process.env && process.env.PINECONE_DEBUG) {
      debugLogMiddleware = {
        pre: function(context) {
          return __awaiter(void 0, void 0, void 0, function() {
            var headers;
            return __generator(this, function(_a) {
              console.debug(chalk(">>> Request: ".concat(context.init.method, " ").concat(context.url), "blue"));
              headers = JSON.parse(JSON.stringify(context.init.headers));
              headers["Api-Key"] = "***REDACTED***";
              console.debug(chalk(">>> Headers: ".concat(JSON.stringify(headers)), "blue"));
              if (context.init.body) {
                console.debug(chalk(">>> Body: ".concat(context.init.body), "blue"));
              }
              console.debug("");
              return [
                2
                /*return*/
              ];
            });
          });
        },
        post: function(context) {
          return __awaiter(void 0, void 0, void 0, function() {
            var _a, _b, _c, _d;
            return __generator(this, function(_e) {
              switch (_e.label) {
                case 0:
                  console.debug(chalk("<<< Status: ".concat(context.response.status), "green"));
                  _b = (_a = console).debug;
                  _c = chalk;
                  _d = "<<< Body: ".concat;
                  return [4, context.response.text()];
                case 1:
                  _b.apply(_a, [_c.apply(void 0, [_d.apply("<<< Body: ", [_e.sent()]), "green"])]);
                  console.debug("");
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        }
      };
      debugMiddleware.push(debugLogMiddleware);
    }
    var debugLogMiddleware;
    if (typeof process !== "undefined" && process && process.env && process.env.PINECONE_DEBUG_CURL) {
      debugCurlMiddleware = {
        post: function(context) {
          return __awaiter(void 0, void 0, void 0, function() {
            var headers, cmd;
            return __generator(this, function(_a) {
              headers = '-H "Api-Key: '.concat((context.init.headers || {})["Api-Key"], '"');
              if (context.init.headers && context.init.headers["Content-Type"]) {
                headers += ' -H "Content-Type: '.concat(context.init.headers["Content-Type"], '"');
              }
              cmd = "curl -X ".concat(context.init.method, " ").concat(context.url, " ").concat(headers, " ").concat(context.init.body ? "-d '".concat(context.init.body, "'") : "");
              console.debug(chalk(cmd, "red"));
              console.debug("");
              return [
                2
                /*return*/
              ];
            });
          });
        }
      };
      debugMiddleware.push(debugCurlMiddleware);
    }
    var debugCurlMiddleware;
    exports.middleware = __spreadArray(__spreadArray([], debugMiddleware, true), [
      {
        onError: function(context) {
          return __awaiter(void 0, void 0, void 0, function() {
            var err;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, (0, errors_1.handleApiError)(context.error, void 0, context.url)];
                case 1:
                  err = _a.sent();
                  throw err;
              }
            });
          });
        },
        post: function(context) {
          return __awaiter(void 0, void 0, void 0, function() {
            var response, err;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  response = context.response;
                  if (!(response.status >= 200 && response.status < 300)) return [3, 1];
                  return [2, response];
                case 1:
                  return [4, (0, errors_1.handleApiError)(new pinecone_generated_ts_fetch_1.ResponseError(response, "Response returned an error"), void 0, context.url)];
                case 2:
                  err = _a.sent();
                  throw err;
              }
            });
          });
        }
      }
    ], false);
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/indexOperationsBuilder.js
var require_indexOperationsBuilder = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/indexOperationsBuilder.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.indexOperationsBuilder = void 0;
    var pinecone_generated_ts_fetch_1 = require_pinecone_generated_ts_fetch();
    var utils_1 = require_utils();
    var middleware_1 = require_middleware();
    var indexOperationsBuilder = function(config) {
      var apiKey = config.apiKey;
      var controllerPath = (0, utils_1.normalizeUrl)(config.controllerHostUrl) || "https://api.pinecone.io";
      var headers = config.additionalHeaders || null;
      var apiConfig = {
        basePath: controllerPath,
        apiKey,
        queryParamsStringify: utils_1.queryParamsStringify,
        headers: __assign({ "User-Agent": (0, utils_1.buildUserAgent)(config) }, headers),
        fetchApi: (0, utils_1.getFetch)(config),
        middleware: middleware_1.middleware
      };
      return new pinecone_generated_ts_fetch_1.ManageIndexesApi(new pinecone_generated_ts_fetch_1.Configuration(apiConfig));
    };
    exports.indexOperationsBuilder = indexOperationsBuilder;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/errors.js
var require_errors2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors2();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors2();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars = __commonJS({
  "node_modules/fast-uri/lib/scopedChars.js"(exports, module) {
    "use strict";
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    module.exports = {
      HEX
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports, module) {
    "use strict";
    var { HEX } = require_scopedChars();
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c of input) {
        if (HEX[c] === void 0) return void 0;
        if (c !== "0" && strip === true) strip = false;
        if (!strip) acc += c;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer.length) {
          if (isZone === false) {
            const hex = stringArrayToHexStripped(buffer);
            if (hex !== void 0) {
              address.push(hex);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer.length = 0;
        }
        return true;
      }
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i - 1 >= 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (isZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host, opts = {}) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i = 0; i < l; i++) {
        const c = str[i];
        if (c === "0" && skip) {
          if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
            out += c;
            skip = false;
          }
        } else {
          if (c === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    var RDS1 = /^\.\.?\//u;
    var RDS2 = /^\/\.(?:\/|$)/u;
    var RDS3 = /^\/\.\.(?:\/|$)/u;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components, options) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false });
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports, module) {
    "use strict";
    var UUID_REG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu;
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path && path !== "/" ? path : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    var http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    var https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    var ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    var wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    var urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    var urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    var SCHEMES = {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    module.exports = SCHEMES;
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports, module) {
    "use strict";
    var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils3();
    var SCHEMES = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeof uri === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    var hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code = 0;
      for (let i = 0, len = value.length; i < len; ++i) {
        code = value.charCodeAt(i);
        if (code > 126 || hexLookUp[code]) {
          return true;
        }
      }
      return false;
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false });
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && !parsed.path && parsed.query === void 0) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path !== void 0 && parsed.path.length) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment !== void 0 && parsed.fragment.length) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponents,
      equal,
      serialize,
      parse
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports.default = Ajv;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports.default = format;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation2();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/@pinecone-database/pinecone/node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports.Ajv = Ajv;
    module.exports = exports = Ajv;
    module.exports.Ajv = Ajv;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/@pinecone-database/pinecone/dist/validator.js
var require_validator = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/validator.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildConfigValidator = exports.buildValidator = exports.errorFormatter = void 0;
    var ajv_1 = __importDefault(require_ajv());
    var errors_1 = require_errors();
    var environment_1 = require_environment();
    var prepend = function(prefix, message) {
      return "".concat(prefix, " ").concat(message);
    };
    var schemaPathPropNameRegex = /properties\/(.+)\//;
    var schemaPathArrayPropNameRegex = /properties\/(.+)\/items/;
    var schemaPathGroupNumberRegex = /anyOf\/(\d+)\/(.+)/;
    var instancePathItemIndexRegex = /(\d+)$/;
    var maxErrors = 3;
    var formatIndividualError = function(e, formattedMessageList) {
      if (e.schemaPath.indexOf("properties") > -1) {
        if (e.schemaPath.indexOf("items") > -1) {
          var propNameMatch = schemaPathArrayPropNameRegex.exec(e.schemaPath);
          var propName = propNameMatch ? propNameMatch[1] : "unknown";
          var itemIndexMatch = instancePathItemIndexRegex.exec(e.instancePath);
          var itemIndex = itemIndexMatch ? itemIndexMatch[1] : "unknown";
          formattedMessageList.push("item at index ".concat(itemIndex, " of the '").concat(propName, "' array ").concat(e.message));
        } else {
          var propNameMatch = schemaPathPropNameRegex.exec(e.schemaPath);
          var propName = propNameMatch ? propNameMatch[1] : "unknown";
          formattedMessageList.push("property '".concat(propName, "' ").concat(e.message));
        }
      } else if (e.schemaPath.indexOf("items") > -1) {
        var itemIndexMatch = instancePathItemIndexRegex.exec(e.instancePath);
        var itemIndex = itemIndexMatch ? itemIndexMatch[1] : "unknown";
        formattedMessageList.push("item at index ".concat(itemIndex, " of the array ").concat(e.message));
      } else if (e.instancePath === "") {
        formattedMessageList.push("argument ".concat(e.message));
      }
    };
    var missingPropertiesErrors = function(subject, errors, messageParts) {
      var missingPropertyNames = errors.filter(function(error) {
        return error.keyword === "required";
      }).map(function(error) {
        return error.params.missingProperty !== void 0 ? error.params.missingProperty : "unknown";
      });
      if (missingPropertyNames.length > 0) {
        var missingMessage = prepend(subject, "".concat(messageParts.length > 0 ? "M" : "m", "ust have required ").concat(missingPropertyNames.length > 1 ? "properties" : "property", ": ").concat(missingPropertyNames.join(", "), "."));
        messageParts.push(missingMessage);
      }
    };
    var neverErrors = function(subject, errors, messageParts) {
      var neverPropertyErrors = errors.filter(function(error) {
        return error.keyword === "not";
      }).map(function(error) {
        return error.instancePath.slice(1);
      });
      if (neverPropertyErrors.length > 0) {
        var neverMessage = prepend(subject, "must not have ".concat(neverPropertyErrors.length > 1 ? "properties" : "property", ": ").concat(neverPropertyErrors.join(", "), "."));
        messageParts.push(neverMessage);
      }
    };
    var typeErrors = function(subject, errors, messageParts) {
      var typeErrorsList = [];
      var anyOfConstPropErrors = errors.filter(function(error2) {
        return error2.schemaPath.indexOf("anyOf") > -1 && error2.keyword === "const" && error2.instancePath.length > 0;
      });
      var errorCount = 0;
      var propErrorGroups = {};
      if (anyOfConstPropErrors.length > 0) {
        for (var _i = 0, anyOfConstPropErrors_1 = anyOfConstPropErrors; _i < anyOfConstPropErrors_1.length; _i++) {
          var error = anyOfConstPropErrors_1[_i];
          var constValue = error.instancePath.slice(1);
          if (propErrorGroups[constValue]) {
            propErrorGroups[constValue].push(error);
          } else {
            propErrorGroups[constValue] = [error];
          }
        }
        var properties = Object.keys(propErrorGroups);
        properties.forEach(function(property) {
          var constValueErrors = propErrorGroups[property];
          typeErrorsList.push("property '".concat(property, "' must be equal to one of: ") + Object.values(constValueErrors).map(function(group) {
            return "'".concat(group.params.allowedValue, "'");
          }).join(", "));
        });
      }
      var anyOfKeys = Object.keys(propErrorGroups);
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e.keyword === "type" && !anyOfKeys.includes(e.instancePath.slice(1))) {
          errorCount += 1;
          if (errorCount <= maxErrors) {
            formatIndividualError(e, typeErrorsList);
          }
        }
      }
      if (errorCount > maxErrors) {
        typeErrorsList.push("and ".concat(errorCount - maxErrors, " other errors"));
      }
      if (typeErrorsList.length > 0) {
        var prefix = messageParts.length > 0 ? "There were also type errors:" : "".concat(subject, " had type errors:");
        var typeErrorMessage = prepend(prefix, typeErrorsList.join(", ")) + ".";
        messageParts.push(typeErrorMessage);
      }
    };
    var validationErrors = function(subject, errors, messageParts) {
      var validationErrors2 = [];
      var errorCount = 0;
      for (var _i = 0, errors_2 = errors; _i < errors_2.length; _i++) {
        var e = errors_2[_i];
        if (e.keyword === "minLength" && e.params.limit === 1) {
          e.message = "must not be blank";
        }
        switch (e.keyword) {
          case "minimum":
          case "maximum":
          case "exclusiveMinimum":
          case "exclusiveMaximum":
          case "minLength":
          case "maxLength":
          case "maxProperties":
          case "minProperties":
          case "minItems":
          case "maxItems":
          case "additionalItems":
          case "additionalProperties":
            errorCount += 1;
            if (errorCount > maxErrors) {
              continue;
            } else {
              formatIndividualError(e, validationErrors2);
            }
            break;
          default:
        }
      }
      if (errorCount > maxErrors) {
        validationErrors2.push("and ".concat(errorCount - maxErrors, " other errors"));
      }
      if (validationErrors2.length > 0) {
        var prefix = messageParts.length > 0 ? "There were also validation errors:" : "".concat(subject, " had validation errors:");
        var validationErrorMessage = prepend(prefix, validationErrors2.join(", ")) + ".";
        messageParts.push(validationErrorMessage);
      }
    };
    var errorFormatter = function(subject, errors) {
      var anyOfArgumentErrors = errors.filter(function(error2) {
        return error2.schemaPath.indexOf("anyOf") > -1 && error2.keyword !== "anyOf" && error2.keyword !== "const" && error2.keyword !== "type";
      });
      if (anyOfArgumentErrors.length > 0) {
        var groups = {};
        for (var _i = 0, anyOfArgumentErrors_1 = anyOfArgumentErrors; _i < anyOfArgumentErrors_1.length; _i++) {
          var error = anyOfArgumentErrors_1[_i];
          var schemaPathMatch = schemaPathGroupNumberRegex.exec(error.schemaPath);
          var groupNumber = schemaPathMatch ? schemaPathMatch[1] : "unknown";
          error.schemaPath = schemaPathMatch ? schemaPathMatch[2] : "unknown";
          if (groups[groupNumber]) {
            groups[groupNumber].push(error);
          } else {
            groups[groupNumber] = [error];
          }
        }
        return "".concat(subject, " accepts multiple types. Either ") + Object.entries(groups).map(function(_a) {
          var key = _a[0], group = _a[1];
          return "".concat(parseInt(key) + 1, ")") + (0, exports.errorFormatter)("", group);
        }).join(" ");
      }
      var messageParts = [];
      neverErrors(subject, errors, messageParts);
      missingPropertiesErrors(subject, errors, messageParts);
      typeErrors(subject, errors, messageParts);
      validationErrors(subject, errors, messageParts);
      return messageParts.join(" ");
    };
    exports.errorFormatter = errorFormatter;
    var buildValidator = function(errorMessagePrefix, schema) {
      if ((0, environment_1.isEdge)()) {
        return function(data) {
        };
      }
      if (typeof process !== "undefined" && process && process.env && process.env.PINECONE_DISABLE_RUNTIME_VALIDATIONS) {
        return function(data) {
        };
      }
      var ajv = new ajv_1.default({ allErrors: true });
      var validate = ajv.compile(schema);
      return function(data) {
        var valid = validate(data);
        if (!valid) {
          var errors = validate.errors || [];
          var msg = (0, exports.errorFormatter)(errorMessagePrefix, errors);
          throw new errors_1.PineconeArgumentError(msg);
        }
        return data;
      };
    };
    exports.buildValidator = buildValidator;
    var buildConfigValidator = function(schema, methodName) {
      var prefix = "The argument to ".concat(methodName);
      return (0, exports.buildValidator)(prefix, schema);
    };
    exports.buildConfigValidator = buildConfigValidator;
  }
});

// node_modules/@sinclair/typebox/typebox.js
var require_typebox = __commonJS({
  "node_modules/@sinclair/typebox/typebox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyResolver = exports.ObjectMap = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Modifier = void 0;
    exports.Modifier = Symbol.for("TypeBox.Modifier");
    exports.Hint = Symbol.for("TypeBox.Hint");
    exports.Kind = Symbol.for("TypeBox.Kind");
    exports.PatternBoolean = "(true|false)";
    exports.PatternNumber = "(0|[1-9][0-9]*)";
    exports.PatternString = "(.*)";
    exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
    exports.PatternNumberExact = `^${exports.PatternNumber}$`;
    exports.PatternStringExact = `^${exports.PatternString}$`;
    var TypeRegistry;
    (function(TypeRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      TypeRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      TypeRegistry2.Clear = Clear;
      function Has(kind) {
        return map.has(kind);
      }
      TypeRegistry2.Has = Has;
      function Set2(kind, func) {
        map.set(kind, func);
      }
      TypeRegistry2.Set = Set2;
      function Get(kind) {
        return map.get(kind);
      }
      TypeRegistry2.Get = Get;
    })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));
    var FormatRegistry;
    (function(FormatRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      FormatRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      FormatRegistry2.Clear = Clear;
      function Has(format) {
        return map.has(format);
      }
      FormatRegistry2.Has = Has;
      function Set2(format, func) {
        map.set(format, func);
      }
      FormatRegistry2.Set = Set2;
      function Get(format) {
        return map.get(format);
      }
      FormatRegistry2.Get = Get;
    })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
    var TypeGuardUnknownTypeError = class extends Error {
      constructor(schema) {
        super("TypeGuard: Unknown type");
        this.schema = schema;
      }
    };
    exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
    var TypeGuard;
    (function(TypeGuard2) {
      function IsObject(value) {
        return typeof value === "object" && value !== null && !Array.isArray(value);
      }
      function IsArray(value) {
        return typeof value === "object" && value !== null && Array.isArray(value);
      }
      function IsPattern(value) {
        try {
          new RegExp(value);
          return true;
        } catch {
          return false;
        }
      }
      function IsControlCharacterFree(value) {
        if (typeof value !== "string")
          return false;
        for (let i = 0; i < value.length; i++) {
          const code = value.charCodeAt(i);
          if (code >= 7 && code <= 13 || code === 27 || code === 127) {
            return false;
          }
        }
        return true;
      }
      function IsAdditionalProperties(value) {
        return IsOptionalBoolean(value) || TSchema(value);
      }
      function IsBigInt(value) {
        return typeof value === "bigint";
      }
      function IsString(value) {
        return typeof value === "string";
      }
      function IsNumber(value) {
        return typeof value === "number" && globalThis.Number.isFinite(value);
      }
      function IsBoolean(value) {
        return typeof value === "boolean";
      }
      function IsOptionalBigInt(value) {
        return value === void 0 || value !== void 0 && IsBigInt(value);
      }
      function IsOptionalNumber(value) {
        return value === void 0 || value !== void 0 && IsNumber(value);
      }
      function IsOptionalBoolean(value) {
        return value === void 0 || value !== void 0 && IsBoolean(value);
      }
      function IsOptionalString(value) {
        return value === void 0 || value !== void 0 && IsString(value);
      }
      function IsOptionalPattern(value) {
        return value === void 0 || value !== void 0 && IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
      }
      function IsOptionalFormat(value) {
        return value === void 0 || value !== void 0 && IsString(value) && IsControlCharacterFree(value);
      }
      function IsOptionalSchema(value) {
        return value === void 0 || TSchema(value);
      }
      function TAny(schema) {
        return TKind(schema) && schema[exports.Kind] === "Any" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TAny = TAny;
      function TArray(schema) {
        return TKind(schema) && schema[exports.Kind] === "Array" && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems);
      }
      TypeGuard2.TArray = TArray;
      function TBigInt(schema) {
        return TKind(schema) && schema[exports.Kind] === "BigInt" && schema.type === "null" && schema.typeOf === "BigInt" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.multipleOf) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.exclusiveMaximum);
      }
      TypeGuard2.TBigInt = TBigInt;
      function TBoolean(schema) {
        return TKind(schema) && schema[exports.Kind] === "Boolean" && schema.type === "boolean" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TBoolean = TBoolean;
      function TConstructor(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Constructor" && schema.type === "object" && schema.instanceOf === "Constructor" && IsOptionalString(schema.$id) && IsArray(schema.parameters) && TSchema(schema.returns))) {
          return false;
        }
        for (const parameter of schema.parameters) {
          if (!TSchema(parameter))
            return false;
        }
        return true;
      }
      TypeGuard2.TConstructor = TConstructor;
      function TDate(schema) {
        return TKind(schema) && schema[exports.Kind] === "Date" && schema.type === "object" && schema.instanceOf === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.exclusiveMaximumTimestamp);
      }
      TypeGuard2.TDate = TDate;
      function TFunction(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Function" && schema.type === "object" && schema.instanceOf === "Function" && IsOptionalString(schema.$id) && IsArray(schema.parameters) && TSchema(schema.returns))) {
          return false;
        }
        for (const parameter of schema.parameters) {
          if (!TSchema(parameter))
            return false;
        }
        return true;
      }
      TypeGuard2.TFunction = TFunction;
      function TInteger(schema) {
        return TKind(schema) && schema[exports.Kind] === "Integer" && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);
      }
      TypeGuard2.TInteger = TInteger;
      function TIntersect(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Intersect" && IsArray(schema.allOf) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id))) {
          return false;
        }
        if ("type" in schema && schema.type !== "object") {
          return false;
        }
        for (const inner of schema.allOf) {
          if (!TSchema(inner))
            return false;
        }
        return true;
      }
      TypeGuard2.TIntersect = TIntersect;
      function TKind(schema) {
        return IsObject(schema) && exports.Kind in schema && typeof schema[exports.Kind] === "string";
      }
      TypeGuard2.TKind = TKind;
      function TLiteralString(schema) {
        return TKind(schema) && schema[exports.Kind] === "Literal" && IsOptionalString(schema.$id) && typeof schema.const === "string";
      }
      TypeGuard2.TLiteralString = TLiteralString;
      function TLiteralNumber(schema) {
        return TKind(schema) && schema[exports.Kind] === "Literal" && IsOptionalString(schema.$id) && typeof schema.const === "number";
      }
      TypeGuard2.TLiteralNumber = TLiteralNumber;
      function TLiteralBoolean(schema) {
        return TKind(schema) && schema[exports.Kind] === "Literal" && IsOptionalString(schema.$id) && typeof schema.const === "boolean";
      }
      TypeGuard2.TLiteralBoolean = TLiteralBoolean;
      function TLiteral(schema) {
        return TLiteralString(schema) || TLiteralNumber(schema) || TLiteralBoolean(schema);
      }
      TypeGuard2.TLiteral = TLiteral;
      function TNever(schema) {
        return TKind(schema) && schema[exports.Kind] === "Never" && IsObject(schema.not) && globalThis.Object.getOwnPropertyNames(schema.not).length === 0;
      }
      TypeGuard2.TNever = TNever;
      function TNot(schema) {
        return TKind(schema) && schema[exports.Kind] === "Not" && TSchema(schema.not);
      }
      TypeGuard2.TNot = TNot;
      function TNull(schema) {
        return TKind(schema) && schema[exports.Kind] === "Null" && schema.type === "null" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TNull = TNull;
      function TNumber(schema) {
        return TKind(schema) && schema[exports.Kind] === "Number" && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);
      }
      TypeGuard2.TNumber = TNumber;
      function TObject(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Object" && schema.type === "object" && IsOptionalString(schema.$id) && IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties))) {
          return false;
        }
        for (const [key, value] of Object.entries(schema.properties)) {
          if (!IsControlCharacterFree(key))
            return false;
          if (!TSchema(value))
            return false;
        }
        return true;
      }
      TypeGuard2.TObject = TObject;
      function TPromise(schema) {
        return TKind(schema) && schema[exports.Kind] === "Promise" && schema.type === "object" && schema.instanceOf === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
      }
      TypeGuard2.TPromise = TPromise;
      function TRecord(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Record" && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && IsObject(schema.patternProperties))) {
          return false;
        }
        const keys = Object.keys(schema.patternProperties);
        if (keys.length !== 1) {
          return false;
        }
        if (!IsPattern(keys[0])) {
          return false;
        }
        if (!TSchema(schema.patternProperties[keys[0]])) {
          return false;
        }
        return true;
      }
      TypeGuard2.TRecord = TRecord;
      function TRef(schema) {
        return TKind(schema) && schema[exports.Kind] === "Ref" && IsOptionalString(schema.$id) && IsString(schema.$ref);
      }
      TypeGuard2.TRef = TRef;
      function TString(schema) {
        return TKind(schema) && schema[exports.Kind] === "String" && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
      }
      TypeGuard2.TString = TString;
      function TSymbol(schema) {
        return TKind(schema) && schema[exports.Kind] === "Symbol" && schema.type === "null" && schema.typeOf === "Symbol" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TSymbol = TSymbol;
      function TTemplateLiteral(schema) {
        return TKind(schema) && schema[exports.Kind] === "TemplateLiteral" && schema.type === "string" && IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
      }
      TypeGuard2.TTemplateLiteral = TTemplateLiteral;
      function TThis(schema) {
        return TKind(schema) && schema[exports.Kind] === "This" && IsOptionalString(schema.$id) && IsString(schema.$ref);
      }
      TypeGuard2.TThis = TThis;
      function TTuple(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Tuple" && schema.type === "array" && IsOptionalString(schema.$id) && IsNumber(schema.minItems) && IsNumber(schema.maxItems) && schema.minItems === schema.maxItems)) {
          return false;
        }
        if (schema.items === void 0 && schema.additionalItems === void 0 && schema.minItems === 0) {
          return true;
        }
        if (!IsArray(schema.items)) {
          return false;
        }
        for (const inner of schema.items) {
          if (!TSchema(inner))
            return false;
        }
        return true;
      }
      TypeGuard2.TTuple = TTuple;
      function TUndefined(schema) {
        return TKind(schema) && schema[exports.Kind] === "Undefined" && schema.type === "null" && schema.typeOf === "Undefined" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TUndefined = TUndefined;
      function TUnionLiteral(schema) {
        return TUnion(schema) && schema.anyOf.every((schema2) => TLiteralString(schema2) || TLiteralNumber(schema2));
      }
      TypeGuard2.TUnionLiteral = TUnionLiteral;
      function TUnion(schema) {
        if (!(TKind(schema) && schema[exports.Kind] === "Union" && IsArray(schema.anyOf) && IsOptionalString(schema.$id))) {
          return false;
        }
        for (const inner of schema.anyOf) {
          if (!TSchema(inner))
            return false;
        }
        return true;
      }
      TypeGuard2.TUnion = TUnion;
      function TUint8Array(schema) {
        return TKind(schema) && schema[exports.Kind] === "Uint8Array" && schema.type === "object" && IsOptionalString(schema.$id) && schema.instanceOf === "Uint8Array" && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
      }
      TypeGuard2.TUint8Array = TUint8Array;
      function TUnknown(schema) {
        return TKind(schema) && schema[exports.Kind] === "Unknown" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TUnknown = TUnknown;
      function TUnsafe(schema) {
        return TKind(schema) && schema[exports.Kind] === "Unsafe";
      }
      TypeGuard2.TUnsafe = TUnsafe;
      function TVoid(schema) {
        return TKind(schema) && schema[exports.Kind] === "Void" && schema.type === "null" && schema.typeOf === "Void" && IsOptionalString(schema.$id);
      }
      TypeGuard2.TVoid = TVoid;
      function TReadonlyOptional(schema) {
        return IsObject(schema) && schema[exports.Modifier] === "ReadonlyOptional";
      }
      TypeGuard2.TReadonlyOptional = TReadonlyOptional;
      function TReadonly(schema) {
        return IsObject(schema) && schema[exports.Modifier] === "Readonly";
      }
      TypeGuard2.TReadonly = TReadonly;
      function TOptional(schema) {
        return IsObject(schema) && schema[exports.Modifier] === "Optional";
      }
      TypeGuard2.TOptional = TOptional;
      function TSchema(schema) {
        return typeof schema === "object" && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));
      }
      TypeGuard2.TSchema = TSchema;
    })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
    var ExtendsUndefined;
    (function(ExtendsUndefined2) {
      function Check(schema) {
        if (schema[exports.Kind] === "Undefined")
          return true;
        if (schema[exports.Kind] === "Not") {
          return !Check(schema.not);
        }
        if (schema[exports.Kind] === "Intersect") {
          const intersect = schema;
          return intersect.allOf.every((schema2) => Check(schema2));
        }
        if (schema[exports.Kind] === "Union") {
          const union = schema;
          return union.anyOf.some((schema2) => Check(schema2));
        }
        return false;
      }
      ExtendsUndefined2.Check = Check;
    })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));
    var TypeExtendsResult;
    (function(TypeExtendsResult2) {
      TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
      TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
      TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
    })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
    var TypeExtends;
    (function(TypeExtends2) {
      function IntoBooleanResult(result) {
        return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;
      }
      function AnyRight(left, right) {
        return TypeExtendsResult.True;
      }
      function Any(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)))
          return TypeExtendsResult.True;
        if (TypeGuard.TUnion(right))
          return TypeExtendsResult.Union;
        if (TypeGuard.TUnknown(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TAny(right))
          return TypeExtendsResult.True;
        return TypeExtendsResult.Union;
      }
      function ArrayRight(left, right) {
        if (TypeGuard.TUnknown(left))
          return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
          return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
          return TypeExtendsResult.True;
        return TypeExtendsResult.False;
      }
      function Array2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))
          return TypeExtendsResult.True;
        if (!TypeGuard.TArray(right))
          return TypeExtendsResult.False;
        return IntoBooleanResult(Visit(left.items, right.items));
      }
      function BigInt(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function BooleanRight(left, right) {
        if (TypeGuard.TLiteral(left) && typeof left.const === "boolean")
          return TypeExtendsResult.True;
        return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Boolean(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Constructor(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (!TypeGuard.TConstructor(right))
          return TypeExtendsResult.False;
        if (left.parameters.length > right.parameters.length)
          return TypeExtendsResult.False;
        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {
          return TypeExtendsResult.False;
        }
        return IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function Date2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Function2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (!TypeGuard.TFunction(right))
          return TypeExtendsResult.False;
        if (left.parameters.length > right.parameters.length)
          return TypeExtendsResult.False;
        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {
          return TypeExtendsResult.False;
        }
        return IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function IntegerRight(left, right) {
        if (TypeGuard.TLiteral(left) && typeof left.const === "number")
          return TypeExtendsResult.True;
        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Integer(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IntersectRight(left, right) {
        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Intersect(left, right) {
        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IsLiteralString(schema) {
        return typeof schema.const === "string";
      }
      function IsLiteralNumber(schema) {
        return typeof schema.const === "number";
      }
      function IsLiteralBoolean(schema) {
        return typeof schema.const === "boolean";
      }
      function Literal(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        if (TypeGuard.TString(right))
          return StringRight(left, right);
        if (TypeGuard.TNumber(right))
          return NumberRight(left, right);
        if (TypeGuard.TInteger(right))
          return IntegerRight(left, right);
        if (TypeGuard.TBoolean(right))
          return BooleanRight(left, right);
        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function NeverRight(left, right) {
        return TypeExtendsResult.False;
      }
      function Never(left, right) {
        return TypeExtendsResult.True;
      }
      function UnwrapNot(schema) {
        let [current, depth] = [schema, 0];
        while (true) {
          if (!TypeGuard.TNot(current))
            break;
          current = current.not;
          depth += 1;
        }
        return depth % 2 === 0 ? current : exports.Type.Unknown();
      }
      function Not(left, right) {
        if (TypeGuard.TNot(left))
          return Visit(UnwrapNot(left), right);
        if (TypeGuard.TNot(right))
          return Visit(left, UnwrapNot(right));
        throw new Error(`TypeExtends: Invalid fallthrough for Not`);
      }
      function Null(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function NumberRight(left, right) {
        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left))
          return TypeExtendsResult.True;
        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Number(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IsObjectPropertyCount(schema, count) {
        return globalThis.Object.keys(schema.properties).length === count;
      }
      function IsObjectStringLike(schema) {
        return IsObjectArrayLike(schema);
      }
      function IsObjectSymbolLike(schema) {
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
      }
      function IsObjectNumberLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectBooleanLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectBigIntLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectDateLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectUint8ArrayLike(schema) {
        return IsObjectArrayLike(schema);
      }
      function IsObjectFunctionLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectConstructorLike(schema) {
        return IsObjectPropertyCount(schema, 0);
      }
      function IsObjectArrayLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectPromiseLike(schema) {
        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === TypeExtendsResult.True;
      }
      function Property(left, right) {
        if (Visit(left, right) === TypeExtendsResult.False)
          return TypeExtendsResult.False;
        if (TypeGuard.TOptional(left) && !TypeGuard.TOptional(right))
          return TypeExtendsResult.False;
        return TypeExtendsResult.True;
      }
      function ObjectRight(left, right) {
        if (TypeGuard.TUnknown(left))
          return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
          return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
          return TypeExtendsResult.True;
        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && IsObjectStringLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left) && IsObjectNumberLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TLiteral(left) && IsLiteralBoolean(left) && IsObjectBooleanLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TString(left) && IsObjectStringLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TNumber(left) && IsObjectNumberLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TInteger(left) && IsObjectNumberLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TDate(left) && IsObjectDateLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TFunction(left) && IsObjectFunctionLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) {
          return right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        if (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) {
          return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        return TypeExtendsResult.False;
      }
      function Object2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        if (!TypeGuard.TObject(right))
          return TypeExtendsResult.False;
        for (const key of globalThis.Object.keys(right.properties)) {
          if (!(key in left.properties))
            return TypeExtendsResult.False;
          if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      }
      function Promise2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectPromiseLike(right))
          return TypeExtendsResult.True;
        if (!TypeGuard.TPromise(right))
          return TypeExtendsResult.False;
        return IntoBooleanResult(Visit(left.item, right.item));
      }
      function RecordKey(schema) {
        if (exports.PatternNumberExact in schema.patternProperties)
          return exports.Type.Number();
        if (exports.PatternStringExact in schema.patternProperties)
          return exports.Type.String();
        throw Error("TypeExtends: Cannot get record key");
      }
      function RecordValue(schema) {
        if (exports.PatternNumberExact in schema.patternProperties)
          return schema.patternProperties[exports.PatternNumberExact];
        if (exports.PatternStringExact in schema.patternProperties)
          return schema.patternProperties[exports.PatternStringExact];
        throw Error("TypeExtends: Cannot get record value");
      }
      function RecordRight(left, right) {
        const Key = RecordKey(right);
        const Value = RecordValue(right);
        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True)
          return TypeExtendsResult.True;
        if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key))
          return Visit(left, Value);
        if (TypeGuard.TString(left) && TypeGuard.TNumber(Key))
          return Visit(left, Value);
        if (TypeGuard.TArray(left) && TypeGuard.TNumber(Key))
          return Visit(left, Value);
        if (TypeGuard.TObject(left)) {
          for (const key of globalThis.Object.keys(left.properties)) {
            if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
              return TypeExtendsResult.False;
            }
          }
          return TypeExtendsResult.True;
        }
        return TypeExtendsResult.False;
      }
      function Record(left, right) {
        const Value = RecordValue(left);
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (!TypeGuard.TRecord(right))
          return TypeExtendsResult.False;
        return Visit(Value, RecordValue(right));
      }
      function StringRight(left, right) {
        if (TypeGuard.TLiteral(left) && typeof left.const === "string")
          return TypeExtendsResult.True;
        return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function String2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Symbol2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TemplateLiteral(left, right) {
        if (TypeGuard.TTemplateLiteral(left))
          return Visit(TemplateLiteralResolver.Resolve(left), right);
        if (TypeGuard.TTemplateLiteral(right))
          return Visit(left, TemplateLiteralResolver.Resolve(right));
        throw new Error(`TypeExtends: Invalid fallthrough for TemplateLiteral`);
      }
      function TupleRight(left, right) {
        if (TypeGuard.TUnknown(left))
          return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
          return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
          return TypeExtendsResult.True;
        return TypeExtendsResult.False;
      }
      function IsArrayOfTuple(left, right) {
        return TypeGuard.TArray(right) && left.items !== void 0 && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);
      }
      function Tuple(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))
          return TypeExtendsResult.True;
        if (TypeGuard.TArray(right) && IsArrayOfTuple(left, right))
          return TypeExtendsResult.True;
        if (!TypeGuard.TTuple(right))
          return TypeExtendsResult.False;
        if (left.items === void 0 && right.items !== void 0 || left.items !== void 0 && right.items === void 0)
          return TypeExtendsResult.False;
        if (left.items === void 0 && right.items === void 0)
          return TypeExtendsResult.True;
        return left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Uint8Array2(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Undefined(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TNever(right))
          return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
          return RecordRight(left, right);
        if (TypeGuard.TVoid(right))
          return VoidRight(left, right);
        return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function UnionRight(left, right) {
        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Union(left, right) {
        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function UnknownRight(left, right) {
        return TypeExtendsResult.True;
      }
      function Unknown(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TString(right))
          return StringRight(left, right);
        if (TypeGuard.TNumber(right))
          return NumberRight(left, right);
        if (TypeGuard.TInteger(right))
          return IntegerRight(left, right);
        if (TypeGuard.TBoolean(right))
          return BooleanRight(left, right);
        if (TypeGuard.TArray(right))
          return ArrayRight(left, right);
        if (TypeGuard.TTuple(right))
          return TupleRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function VoidRight(left, right) {
        if (TypeGuard.TUndefined(left))
          return TypeExtendsResult.True;
        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Void(left, right) {
        if (TypeGuard.TIntersect(right))
          return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
          return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
          return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
          return AnyRight(left, right);
        if (TypeGuard.TObject(right))
          return ObjectRight(left, right);
        return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Visit(left, right) {
        if (TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right))
          return TemplateLiteral(left, right);
        if (TypeGuard.TNot(left) || TypeGuard.TNot(right))
          return Not(left, right);
        if (TypeGuard.TAny(left))
          return Any(left, right);
        if (TypeGuard.TArray(left))
          return Array2(left, right);
        if (TypeGuard.TBigInt(left))
          return BigInt(left, right);
        if (TypeGuard.TBoolean(left))
          return Boolean(left, right);
        if (TypeGuard.TConstructor(left))
          return Constructor(left, right);
        if (TypeGuard.TDate(left))
          return Date2(left, right);
        if (TypeGuard.TFunction(left))
          return Function2(left, right);
        if (TypeGuard.TInteger(left))
          return Integer(left, right);
        if (TypeGuard.TIntersect(left))
          return Intersect(left, right);
        if (TypeGuard.TLiteral(left))
          return Literal(left, right);
        if (TypeGuard.TNever(left))
          return Never(left, right);
        if (TypeGuard.TNull(left))
          return Null(left, right);
        if (TypeGuard.TNumber(left))
          return Number(left, right);
        if (TypeGuard.TObject(left))
          return Object2(left, right);
        if (TypeGuard.TRecord(left))
          return Record(left, right);
        if (TypeGuard.TString(left))
          return String2(left, right);
        if (TypeGuard.TSymbol(left))
          return Symbol2(left, right);
        if (TypeGuard.TTuple(left))
          return Tuple(left, right);
        if (TypeGuard.TPromise(left))
          return Promise2(left, right);
        if (TypeGuard.TUint8Array(left))
          return Uint8Array2(left, right);
        if (TypeGuard.TUndefined(left))
          return Undefined(left, right);
        if (TypeGuard.TUnion(left))
          return Union(left, right);
        if (TypeGuard.TUnknown(left))
          return Unknown(left, right);
        if (TypeGuard.TVoid(left))
          return Void(left, right);
        throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);
      }
      function Extends(left, right) {
        return Visit(left, right);
      }
      TypeExtends2.Extends = Extends;
    })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
    var TypeClone;
    (function(TypeClone2) {
      function IsObject(value) {
        return typeof value === "object" && value !== null;
      }
      function IsArray(value) {
        return globalThis.Array.isArray(value);
      }
      function Array2(value) {
        return value.map((value2) => Visit(value2));
      }
      function Object2(value) {
        const clonedProperties = globalThis.Object.getOwnPropertyNames(value).reduce((acc, key) => {
          return { ...acc, [key]: Visit(value[key]) };
        }, {});
        const clonedSymbols = globalThis.Object.getOwnPropertySymbols(value).reduce((acc, key) => {
          return { ...acc, [key]: Visit(value[key]) };
        }, {});
        return { ...clonedProperties, ...clonedSymbols };
      }
      function Visit(value) {
        if (IsArray(value))
          return Array2(value);
        if (IsObject(value))
          return Object2(value);
        return value;
      }
      function Clone(schema, options) {
        return { ...Visit(schema), ...options };
      }
      TypeClone2.Clone = Clone;
    })(TypeClone || (exports.TypeClone = TypeClone = {}));
    var IndexedAccessor;
    (function(IndexedAccessor2) {
      function OptionalUnwrap(schema) {
        return schema.map((schema2) => {
          const { [exports.Modifier]: _, ...clone } = TypeClone.Clone(schema2, {});
          return clone;
        });
      }
      function IsIntersectOptional(schema) {
        return schema.every((schema2) => TypeGuard.TOptional(schema2));
      }
      function IsUnionOptional(schema) {
        return schema.some((schema2) => TypeGuard.TOptional(schema2));
      }
      function ResolveIntersect(schema) {
        const optional = IsIntersectOptional(schema.allOf);
        return optional ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
      }
      function ResolveUnion(schema) {
        const optional = IsUnionOptional(schema.anyOf);
        return optional ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
      }
      function ResolveOptional(schema) {
        if (schema[exports.Kind] === "Intersect")
          return ResolveIntersect(schema);
        if (schema[exports.Kind] === "Union")
          return ResolveUnion(schema);
        return schema;
      }
      function Intersect(schema, key) {
        const resolved = schema.allOf.reduce((acc, schema2) => {
          const indexed = Visit(schema2, key);
          return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
        }, []);
        return ResolveOptional(exports.Type.Intersect(resolved));
      }
      function Union(schema, key) {
        const resolved = schema.anyOf.map((schema2) => Visit(schema2, key));
        return ResolveOptional(exports.Type.Union(resolved));
      }
      function Object2(schema, key) {
        const property = schema.properties[key];
        return property === void 0 ? exports.Type.Never() : exports.Type.Union([property]);
      }
      function Tuple(schema, key) {
        const items = schema.items;
        if (items === void 0)
          return exports.Type.Never();
        const element = items[key];
        if (element === void 0)
          return exports.Type.Never();
        return element;
      }
      function Visit(schema, key) {
        if (schema[exports.Kind] === "Intersect")
          return Intersect(schema, key);
        if (schema[exports.Kind] === "Union")
          return Union(schema, key);
        if (schema[exports.Kind] === "Object")
          return Object2(schema, key);
        if (schema[exports.Kind] === "Tuple")
          return Tuple(schema, key);
        return exports.Type.Never();
      }
      function Resolve(schema, keys, options = {}) {
        const resolved = keys.map((key) => Visit(schema, key.toString()));
        return ResolveOptional(exports.Type.Union(resolved, options));
      }
      IndexedAccessor2.Resolve = Resolve;
    })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
    var ObjectMap;
    (function(ObjectMap2) {
      function Intersect(schema, callback) {
        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });
      }
      function Union(schema, callback) {
        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });
      }
      function Object2(schema, callback) {
        return callback(schema);
      }
      function Visit(schema, callback) {
        if (schema[exports.Kind] === "Intersect")
          return Intersect(schema, callback);
        if (schema[exports.Kind] === "Union")
          return Union(schema, callback);
        if (schema[exports.Kind] === "Object")
          return Object2(schema, callback);
        return schema;
      }
      function Map2(schema, callback, options) {
        return { ...Visit(TypeClone.Clone(schema, {}), callback), ...options };
      }
      ObjectMap2.Map = Map2;
    })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
    var KeyResolver;
    (function(KeyResolver2) {
      function UnwrapPattern(key) {
        return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
      }
      function Intersect(schema, options) {
        return schema.allOf.reduce((acc, schema2) => [...acc, ...Visit(schema2, options)], []);
      }
      function Union(schema, options) {
        const sets = schema.anyOf.map((inner) => Visit(inner, options));
        return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], /* @__PURE__ */ new Set())];
      }
      function Object2(schema, options) {
        return globalThis.Object.keys(schema.properties);
      }
      function Record(schema, options) {
        return options.includePatterns ? globalThis.Object.keys(schema.patternProperties) : [];
      }
      function Visit(schema, options) {
        if (TypeGuard.TIntersect(schema))
          return Intersect(schema, options);
        if (TypeGuard.TUnion(schema))
          return Union(schema, options);
        if (TypeGuard.TObject(schema))
          return Object2(schema, options);
        if (TypeGuard.TRecord(schema))
          return Record(schema, options);
        return [];
      }
      function ResolveKeys(schema, options) {
        return [...new Set(Visit(schema, options))];
      }
      KeyResolver2.ResolveKeys = ResolveKeys;
      function ResolvePattern(schema) {
        const keys = ResolveKeys(schema, { includePatterns: true });
        const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);
        return `^(${pattern.join("|")})$`;
      }
      KeyResolver2.ResolvePattern = ResolvePattern;
    })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));
    var KeyArrayResolver;
    (function(KeyArrayResolver2) {
      function Resolve(schema) {
        if (globalThis.Array.isArray(schema))
          return schema;
        if (TypeGuard.TUnionLiteral(schema))
          return schema.anyOf.map((schema2) => schema2.const.toString());
        if (TypeGuard.TLiteral(schema))
          return [schema.const];
        if (TypeGuard.TTemplateLiteral(schema)) {
          const expression = TemplateLiteralParser.ParseExact(schema.pattern);
          if (!TemplateLiteralFinite.Check(expression))
            throw Error("KeyArrayResolver: Cannot resolve keys from infinite template expression");
          return [...TemplateLiteralGenerator.Generate(expression)];
        }
        return [];
      }
      KeyArrayResolver2.Resolve = Resolve;
    })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
    var UnionResolver;
    (function(UnionResolver2) {
      function* Union(union) {
        for (const schema of union.anyOf) {
          if (schema[exports.Kind] === "Union") {
            yield* Union(schema);
          } else {
            yield schema;
          }
        }
      }
      function Resolve(union) {
        return exports.Type.Union([...Union(union)], { ...union });
      }
      UnionResolver2.Resolve = Resolve;
    })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));
    var TemplateLiteralPattern;
    (function(TemplateLiteralPattern2) {
      function Escape(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function Visit(schema, acc) {
        if (TypeGuard.TTemplateLiteral(schema)) {
          const pattern = schema.pattern.slice(1, schema.pattern.length - 1);
          return pattern;
        } else if (TypeGuard.TUnion(schema)) {
          const tokens = schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|");
          return `(${tokens})`;
        } else if (TypeGuard.TNumber(schema)) {
          return `${acc}${exports.PatternNumber}`;
        } else if (TypeGuard.TInteger(schema)) {
          return `${acc}${exports.PatternNumber}`;
        } else if (TypeGuard.TBigInt(schema)) {
          return `${acc}${exports.PatternNumber}`;
        } else if (TypeGuard.TString(schema)) {
          return `${acc}${exports.PatternString}`;
        } else if (TypeGuard.TLiteral(schema)) {
          return `${acc}${Escape(schema.const.toString())}`;
        } else if (TypeGuard.TBoolean(schema)) {
          return `${acc}${exports.PatternBoolean}`;
        } else if (TypeGuard.TNever(schema)) {
          throw Error("TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever");
        } else {
          throw Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);
        }
      }
      function Create(kinds) {
        return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
      }
      TemplateLiteralPattern2.Create = Create;
    })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
    var TemplateLiteralResolver;
    (function(TemplateLiteralResolver2) {
      function Resolve(template) {
        const expression = TemplateLiteralParser.ParseExact(template.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          return exports.Type.String();
        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
        return exports.Type.Union(literals);
      }
      TemplateLiteralResolver2.Resolve = Resolve;
    })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));
    var TemplateLiteralParserError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports.TemplateLiteralParserError = TemplateLiteralParserError;
    var TemplateLiteralParser;
    (function(TemplateLiteralParser2) {
      function IsNonEscaped(pattern, index, char) {
        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
      }
      function IsOpenParen(pattern, index) {
        return IsNonEscaped(pattern, index, "(");
      }
      function IsCloseParen(pattern, index) {
        return IsNonEscaped(pattern, index, ")");
      }
      function IsSeparator(pattern, index) {
        return IsNonEscaped(pattern, index, "|");
      }
      function IsGroup(pattern) {
        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
          return false;
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (count === 0 && index !== pattern.length - 1)
            return false;
        }
        return true;
      }
      function InGroup(pattern) {
        return pattern.slice(1, pattern.length - 1);
      }
      function IsPrecedenceOr(pattern) {
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (IsSeparator(pattern, index) && count === 0)
            return true;
        }
        return false;
      }
      function IsPrecedenceAnd(pattern) {
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            return true;
        }
        return false;
      }
      function Or(pattern) {
        let [count, start] = [0, 0];
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index))
            count += 1;
          if (IsCloseParen(pattern, index))
            count -= 1;
          if (IsSeparator(pattern, index) && count === 0) {
            const range2 = pattern.slice(start, index);
            if (range2.length > 0)
              expressions.push(Parse(range2));
            start = index + 1;
          }
        }
        const range = pattern.slice(start);
        if (range.length > 0)
          expressions.push(Parse(range));
        if (expressions.length === 0)
          return { type: "const", const: "" };
        if (expressions.length === 1)
          return expressions[0];
        return { type: "or", expr: expressions };
      }
      function And(pattern) {
        function Group(value, index) {
          if (!IsOpenParen(value, index))
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
          let count = 0;
          for (let scan = index; scan < value.length; scan++) {
            if (IsOpenParen(value, scan))
              count += 1;
            if (IsCloseParen(value, scan))
              count -= 1;
            if (count === 0)
              return [index, scan];
          }
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
        }
        function Range(pattern2, index) {
          for (let scan = index; scan < pattern2.length; scan++) {
            if (IsOpenParen(pattern2, scan))
              return [index, scan];
          }
          return [index, pattern2.length];
        }
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
          if (IsOpenParen(pattern, index)) {
            const [start, end] = Group(pattern, index);
            const range = pattern.slice(start, end + 1);
            expressions.push(Parse(range));
            index = end;
          } else {
            const [start, end] = Range(pattern, index);
            const range = pattern.slice(start, end);
            if (range.length > 0)
              expressions.push(Parse(range));
            index = end - 1;
          }
        }
        if (expressions.length === 0)
          return { type: "const", const: "" };
        if (expressions.length === 1)
          return expressions[0];
        return { type: "and", expr: expressions };
      }
      function Parse(pattern) {
        if (IsGroup(pattern))
          return Parse(InGroup(pattern));
        if (IsPrecedenceOr(pattern))
          return Or(pattern);
        if (IsPrecedenceAnd(pattern))
          return And(pattern);
        return { type: "const", const: pattern };
      }
      TemplateLiteralParser2.Parse = Parse;
      function ParseExact(pattern) {
        return Parse(pattern.slice(1, pattern.length - 1));
      }
      TemplateLiteralParser2.ParseExact = ParseExact;
    })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));
    var TemplateLiteralFinite;
    (function(TemplateLiteralFinite2) {
      function IsNumber(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
      }
      function IsBoolean(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
      }
      function IsString(expression) {
        return expression.type === "const" && expression.const === ".*";
      }
      function Check(expression) {
        if (IsBoolean(expression))
          return true;
        if (IsNumber(expression) || IsString(expression))
          return false;
        if (expression.type === "and")
          return expression.expr.every((expr) => Check(expr));
        if (expression.type === "or")
          return expression.expr.every((expr) => Check(expr));
        if (expression.type === "const")
          return true;
        throw Error(`TemplateLiteralFinite: Unknown expression type`);
      }
      TemplateLiteralFinite2.Check = Check;
    })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));
    var TemplateLiteralGenerator;
    (function(TemplateLiteralGenerator2) {
      function* Reduce(buffer) {
        if (buffer.length === 1)
          return yield* buffer[0];
        for (const left of buffer[0]) {
          for (const right of Reduce(buffer.slice(1))) {
            yield `${left}${right}`;
          }
        }
      }
      function* And(expression) {
        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
      }
      function* Or(expression) {
        for (const expr of expression.expr)
          yield* Generate(expr);
      }
      function* Const(expression) {
        return yield expression.const;
      }
      function* Generate(expression) {
        if (expression.type === "and")
          return yield* And(expression);
        if (expression.type === "or")
          return yield* Or(expression);
        if (expression.type === "const")
          return yield* Const(expression);
        throw Error("TemplateLiteralGenerator: Unknown expression");
      }
      TemplateLiteralGenerator2.Generate = Generate;
    })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
    var TemplateLiteralDslParser;
    (function(TemplateLiteralDslParser2) {
      function* ParseUnion(template) {
        const trim = template.trim().replace(/"|'/g, "");
        if (trim === "boolean")
          return yield exports.Type.Boolean();
        if (trim === "number")
          return yield exports.Type.Number();
        if (trim === "bigint")
          return yield exports.Type.BigInt();
        if (trim === "string")
          return yield exports.Type.String();
        const literals = trim.split("|").map((literal) => exports.Type.Literal(literal.trim()));
        return yield literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
      }
      function* ParseTerminal(template) {
        if (template[1] !== "{") {
          const L = exports.Type.Literal("$");
          const R = ParseLiteral(template.slice(1));
          return yield* [L, ...R];
        }
        for (let i = 2; i < template.length; i++) {
          if (template[i] === "}") {
            const L = ParseUnion(template.slice(2, i));
            const R = ParseLiteral(template.slice(i + 1));
            return yield* [...L, ...R];
          }
        }
        yield exports.Type.Literal(template);
      }
      function* ParseLiteral(template) {
        for (let i = 0; i < template.length; i++) {
          if (template[i] === "$") {
            const L = exports.Type.Literal(template.slice(0, i));
            const R = ParseTerminal(template.slice(i));
            return yield* [L, ...R];
          }
        }
        yield exports.Type.Literal(template);
      }
      function Parse(template_dsl) {
        return [...ParseLiteral(template_dsl)];
      }
      TemplateLiteralDslParser2.Parse = Parse;
    })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
    var TypeOrdinal = 0;
    var TypeBuilder = class {
      /** `[Utility]` Creates a schema without `static` and `params` types */
      Create(schema) {
        return schema;
      }
      /** `[Standard]` Omits compositing symbols from this schema */
      Strict(schema) {
        return JSON.parse(JSON.stringify(schema));
      }
    };
    exports.TypeBuilder = TypeBuilder;
    var StandardTypeBuilder = class extends TypeBuilder {
      // ------------------------------------------------------------------------
      // Modifiers
      // ------------------------------------------------------------------------
      /** `[Modifier]` Creates a Optional property */
      Optional(schema) {
        return { [exports.Modifier]: "Optional", ...TypeClone.Clone(schema, {}) };
      }
      /** `[Modifier]` Creates a ReadonlyOptional property */
      ReadonlyOptional(schema) {
        return { [exports.Modifier]: "ReadonlyOptional", ...TypeClone.Clone(schema, {}) };
      }
      /** `[Modifier]` Creates a Readonly object or property */
      Readonly(schema) {
        return { [exports.Modifier]: "Readonly", ...schema };
      }
      // ------------------------------------------------------------------------
      // Types
      // ------------------------------------------------------------------------
      /** `[Standard]` Creates an Any type */
      Any(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Any" });
      }
      /** `[Standard]` Creates an Array type */
      Array(items, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Array", type: "array", items: TypeClone.Clone(items, {}) });
      }
      /** `[Standard]` Creates a Boolean type */
      Boolean(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Boolean", type: "boolean" });
      }
      /** `[Standard]` Creates a Composite object type. */
      Composite(objects, options) {
        const intersect = exports.Type.Intersect(objects, {});
        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});
        return exports.Type.Object(properties, options);
      }
      /** `[Standard]` Creates a Enum type */
      Enum(item, options = {}) {
        const values = globalThis.Object.keys(item).filter((key) => isNaN(key)).map((key) => item[key]);
        const anyOf = values.map((value) => typeof value === "string" ? { [exports.Kind]: "Literal", type: "string", const: value } : { [exports.Kind]: "Literal", type: "number", const: value });
        return this.Create({ ...options, [exports.Kind]: "Union", anyOf });
      }
      /** `[Standard]` A conditional type expression that will return the true type if the left type extends the right */
      Extends(left, right, trueType, falseType, options = {}) {
        switch (TypeExtends.Extends(left, right)) {
          case TypeExtendsResult.Union:
            return this.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);
          case TypeExtendsResult.True:
            return TypeClone.Clone(trueType, options);
          case TypeExtendsResult.False:
            return TypeClone.Clone(falseType, options);
        }
      }
      /** `[Standard]` Excludes from the left type any type that is not assignable to the right */
      Exclude(left, right, options = {}) {
        if (TypeGuard.TTemplateLiteral(left))
          return this.Exclude(TemplateLiteralResolver.Resolve(left), right, options);
        if (TypeGuard.TTemplateLiteral(right))
          return this.Exclude(left, TemplateLiteralResolver.Resolve(right), options);
        if (TypeGuard.TUnion(left)) {
          const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) === TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);
        } else {
          return TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(left, options);
        }
      }
      /** `[Standard]` Extracts from the left type any type that is assignable to the right */
      Extract(left, right, options = {}) {
        if (TypeGuard.TTemplateLiteral(left))
          return this.Extract(TemplateLiteralResolver.Resolve(left), right, options);
        if (TypeGuard.TTemplateLiteral(right))
          return this.Extract(left, TemplateLiteralResolver.Resolve(right), options);
        if (TypeGuard.TUnion(left)) {
          const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) !== TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);
        } else {
          return TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? TypeClone.Clone(left, options) : this.Never(options);
        }
      }
      /** `[Standard]` Returns indexed property types for the given keys */
      Index(schema, unresolved, options = {}) {
        if (TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved)) {
          return TypeClone.Clone(schema.items, options);
        } else if (TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved)) {
          const items = schema.items === void 0 ? [] : schema.items;
          const cloned = items.map((schema2) => TypeClone.Clone(schema2, {}));
          return this.Union(cloned, options);
        } else {
          const keys = KeyArrayResolver.Resolve(unresolved);
          const clone = TypeClone.Clone(schema, {});
          return IndexedAccessor.Resolve(clone, keys, options);
        }
      }
      /** `[Standard]` Creates an Integer type */
      Integer(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Integer", type: "integer" });
      }
      Intersect(allOf, options = {}) {
        if (allOf.length === 0)
          return exports.Type.Never();
        if (allOf.length === 1)
          return TypeClone.Clone(allOf[0], options);
        const objects = allOf.every((schema) => TypeGuard.TObject(schema));
        const cloned = allOf.map((schema) => TypeClone.Clone(schema, {}));
        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties, {}) } : {};
        if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {
          return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", type: "object", allOf: cloned });
        } else {
          return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", allOf: cloned });
        }
      }
      /** `[Standard]` Creates a KeyOf type */
      KeyOf(schema, options = {}) {
        if (TypeGuard.TRecord(schema)) {
          const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
          if (pattern === exports.PatternNumberExact)
            return this.Number(options);
          if (pattern === exports.PatternStringExact)
            return this.String(options);
          throw Error("StandardTypeBuilder: Unable to resolve key type from Record key pattern");
        } else if (TypeGuard.TTuple(schema)) {
          const items = schema.items === void 0 ? [] : schema.items;
          const literals = items.map((_, index) => exports.Type.Literal(index));
          return this.Union(literals, options);
        } else if (TypeGuard.TArray(schema)) {
          return this.Number(options);
        } else {
          const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });
          if (keys.length === 0)
            return this.Never(options);
          const literals = keys.map((key) => this.Literal(key));
          return this.Union(literals, options);
        }
      }
      /** `[Standard]` Creates a Literal type */
      Literal(value, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Literal", const: value, type: typeof value });
      }
      /** `[Standard]` Creates a Never type */
      Never(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
      }
      /** `[Standard]` Creates a Not type */
      Not(not, options) {
        return this.Create({ ...options, [exports.Kind]: "Not", not });
      }
      /** `[Standard]` Creates a Null type */
      Null(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Null", type: "null" });
      }
      /** `[Standard]` Creates a Number type */
      Number(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Number", type: "number" });
      }
      /** `[Standard]` Creates an Object type */
      Object(properties, options = {}) {
        const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]) || TypeGuard.TReadonlyOptional(properties[key]));
        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Clone(options.additionalProperties, {}) } : {};
        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(properties[key], {}) }), {});
        if (requiredKeys.length > 0) {
          return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys });
        } else {
          return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties });
        }
      }
      Omit(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema2) => {
          if (schema2.required) {
            schema2.required = schema2.required.filter((key) => !keys.includes(key));
            if (schema2.required.length === 0)
              delete schema2.required;
          }
          for (const key of globalThis.Object.keys(schema2.properties)) {
            if (keys.includes(key))
              delete schema2.properties[key];
          }
          return this.Create(schema2);
        }, options);
      }
      /** `[Standard]` Creates a mapped type where all properties are Optional */
      Partial(schema, options = {}) {
        function Apply(schema2) {
          switch (schema2[exports.Modifier]) {
            case "ReadonlyOptional":
              schema2[exports.Modifier] = "ReadonlyOptional";
              break;
            case "Readonly":
              schema2[exports.Modifier] = "ReadonlyOptional";
              break;
            case "Optional":
              schema2[exports.Modifier] = "Optional";
              break;
            default:
              schema2[exports.Modifier] = "Optional";
              break;
          }
        }
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema2) => {
          delete schema2.required;
          globalThis.Object.keys(schema2.properties).forEach((key) => Apply(schema2.properties[key]));
          return schema2;
        }, options);
      }
      Pick(schema, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema2) => {
          if (schema2.required) {
            schema2.required = schema2.required.filter((key) => keys.includes(key));
            if (schema2.required.length === 0)
              delete schema2.required;
          }
          for (const key of globalThis.Object.keys(schema2.properties)) {
            if (!keys.includes(key))
              delete schema2.properties[key];
          }
          return this.Create(schema2);
        }, options);
      }
      /** `[Standard]` Creates a Record type */
      Record(key, schema, options = {}) {
        if (TypeGuard.TTemplateLiteral(key)) {
          const expression = TemplateLiteralParser.ParseExact(key.pattern);
          return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Clone(schema, {}) }), {}), options) : this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Clone(schema, {}) } });
        } else if (TypeGuard.TUnion(key)) {
          const union = UnionResolver.Resolve(key);
          if (TypeGuard.TUnionLiteral(union)) {
            const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Clone(schema, {}) }), {});
            return this.Object(properties, { ...options, [exports.Hint]: "Record" });
          } else
            throw Error("TypeBuilder: Record key of type union contains non-literal types");
        } else if (TypeGuard.TLiteral(key)) {
          if (typeof key.const === "string" || typeof key.const === "number") {
            return this.Object({ [key.const]: TypeClone.Clone(schema, {}) }, options);
          } else
            throw Error("TypeBuilder: Record key of type literal is not of type string or number");
        } else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {
          const pattern = exports.PatternNumberExact;
          return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Clone(schema, {}) } });
        } else if (TypeGuard.TString(key)) {
          const pattern = key.pattern === void 0 ? exports.PatternStringExact : key.pattern;
          return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Clone(schema, {}) } });
        } else {
          throw Error(`StandardTypeBuilder: Record key is an invalid type`);
        }
      }
      /** `[Standard]` Creates a Recursive type */
      Recursive(callback, options = {}) {
        if (options.$id === void 0)
          options.$id = `T${TypeOrdinal++}`;
        const thisType = callback({ [exports.Kind]: "This", $ref: `${options.$id}` });
        thisType.$id = options.$id;
        return this.Create({ ...options, [exports.Hint]: "Recursive", ...thisType });
      }
      /** `[Standard]` Creates a Ref type. The referenced type must contain a $id */
      Ref(schema, options = {}) {
        if (schema.$id === void 0)
          throw Error("StandardTypeBuilder.Ref: Target type must specify an $id");
        return this.Create({ ...options, [exports.Kind]: "Ref", $ref: schema.$id });
      }
      /** `[Standard]` Creates a mapped type where all properties are Required */
      Required(schema, options = {}) {
        function Apply(schema2) {
          switch (schema2[exports.Modifier]) {
            case "ReadonlyOptional":
              schema2[exports.Modifier] = "Readonly";
              break;
            case "Readonly":
              schema2[exports.Modifier] = "Readonly";
              break;
            case "Optional":
              delete schema2[exports.Modifier];
              break;
            default:
              delete schema2[exports.Modifier];
              break;
          }
        }
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema2) => {
          schema2.required = globalThis.Object.keys(schema2.properties);
          globalThis.Object.keys(schema2.properties).forEach((key) => Apply(schema2.properties[key]));
          return schema2;
        }, options);
      }
      /** `[Standard]` Returns a schema array which allows types to compose with the JavaScript spread operator */
      Rest(schema) {
        if (TypeGuard.TTuple(schema)) {
          if (schema.items === void 0)
            return [];
          return schema.items.map((schema2) => TypeClone.Clone(schema2, {}));
        } else {
          return [TypeClone.Clone(schema, {})];
        }
      }
      /** `[Standard]` Creates a String type */
      String(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "String", type: "string" });
      }
      /** `[Standard]` Creates a template literal type */
      TemplateLiteral(unresolved, options = {}) {
        const pattern = typeof unresolved === "string" ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
        return this.Create({ ...options, [exports.Kind]: "TemplateLiteral", type: "string", pattern });
      }
      /** `[Standard]` Creates a Tuple type */
      Tuple(items, options = {}) {
        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
        const clonedItems = items.map((item) => TypeClone.Clone(item, {}));
        const schema = items.length > 0 ? { ...options, [exports.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports.Kind]: "Tuple", type: "array", minItems, maxItems };
        return this.Create(schema);
      }
      Union(union, options = {}) {
        if (TypeGuard.TTemplateLiteral(union)) {
          return TemplateLiteralResolver.Resolve(union);
        } else {
          const anyOf = union;
          if (anyOf.length === 0)
            return this.Never(options);
          if (anyOf.length === 1)
            return this.Create(TypeClone.Clone(anyOf[0], options));
          const clonedAnyOf = anyOf.map((schema) => TypeClone.Clone(schema, {}));
          return this.Create({ ...options, [exports.Kind]: "Union", anyOf: clonedAnyOf });
        }
      }
      /** `[Standard]` Creates an Unknown type */
      Unknown(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Unknown" });
      }
      /** `[Standard]` Creates a Unsafe type that infers for the generic argument */
      Unsafe(options = {}) {
        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || "Unsafe" });
      }
    };
    exports.StandardTypeBuilder = StandardTypeBuilder;
    var ExtendedTypeBuilder = class extends StandardTypeBuilder {
      /** `[Extended]` Creates a BigInt type */
      BigInt(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "BigInt", type: "null", typeOf: "BigInt" });
      }
      /** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */
      ConstructorParameters(schema, options = {}) {
        return this.Tuple([...schema.parameters], { ...options });
      }
      /** `[Extended]` Creates a Constructor type */
      Constructor(parameters, returns, options) {
        const clonedReturns = TypeClone.Clone(returns, {});
        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));
        return this.Create({ ...options, [exports.Kind]: "Constructor", type: "object", instanceOf: "Constructor", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[Extended]` Creates a Date type */
      Date(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Date", type: "object", instanceOf: "Date" });
      }
      /** `[Extended]` Creates a Function type */
      Function(parameters, returns, options) {
        const clonedReturns = TypeClone.Clone(returns, {});
        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));
        return this.Create({ ...options, [exports.Kind]: "Function", type: "object", instanceOf: "Function", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[Extended]` Extracts the InstanceType from the given Constructor */
      InstanceType(schema, options = {}) {
        return TypeClone.Clone(schema.returns, options);
      }
      /** `[Extended]` Extracts the Parameters from the given Function type */
      Parameters(schema, options = {}) {
        return this.Tuple(schema.parameters, { ...options });
      }
      /** `[Extended]` Creates a Promise type */
      Promise(item, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Promise", type: "object", instanceOf: "Promise", item: TypeClone.Clone(item, {}) });
      }
      /** `[Extended]` Creates a regular expression type */
      RegEx(regex, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "String", type: "string", pattern: regex.source });
      }
      /** `[Extended]` Extracts the ReturnType from the given Function */
      ReturnType(schema, options = {}) {
        return TypeClone.Clone(schema.returns, options);
      }
      /** `[Extended]` Creates a Symbol type */
      Symbol(options) {
        return this.Create({ ...options, [exports.Kind]: "Symbol", type: "null", typeOf: "Symbol" });
      }
      /** `[Extended]` Creates a Undefined type */
      Undefined(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Undefined", type: "null", typeOf: "Undefined" });
      }
      /** `[Extended]` Creates a Uint8Array type */
      Uint8Array(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Uint8Array", type: "object", instanceOf: "Uint8Array" });
      }
      /** `[Extended]` Creates a Void type */
      Void(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Void", type: "null", typeOf: "Void" });
      }
    };
    exports.ExtendedTypeBuilder = ExtendedTypeBuilder;
    exports.StandardType = new StandardTypeBuilder();
    exports.Type = new ExtendedTypeBuilder();
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/types.js
var require_types2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionNameSchema = exports.MetadataConfigSchema = exports.CapacityModeSchema = exports.CloudSchema = exports.EnvironmentSchema = exports.RegionSchema = exports.DimensionSchema = exports.MetricSchema = exports.ShardsSchema = exports.PodsSchema = exports.ReplicasSchema = exports.PodTypeSchema = exports.IndexNameSchema = void 0;
    var typebox_1 = require_typebox();
    var nonemptyString = typebox_1.Type.String({ minLength: 1 });
    var positiveInteger = typebox_1.Type.Integer({ minimum: 1 });
    exports.IndexNameSchema = nonemptyString;
    exports.PodTypeSchema = nonemptyString;
    exports.ReplicasSchema = positiveInteger;
    exports.PodsSchema = positiveInteger;
    exports.ShardsSchema = positiveInteger;
    exports.MetricSchema = typebox_1.Type.Union([
      typebox_1.Type.Literal("cosine"),
      typebox_1.Type.Literal("euclidean"),
      typebox_1.Type.Literal("dotproduct")
    ]);
    exports.DimensionSchema = positiveInteger;
    exports.RegionSchema = nonemptyString;
    exports.EnvironmentSchema = nonemptyString;
    exports.CloudSchema = typebox_1.Type.Union([
      typebox_1.Type.Literal("gcp"),
      typebox_1.Type.Literal("aws"),
      typebox_1.Type.Literal("azure")
    ]);
    exports.CapacityModeSchema = nonemptyString;
    exports.MetadataConfigSchema = typebox_1.Type.Object({
      indexed: typebox_1.Type.Array(nonemptyString)
    }, { additionalProperties: false });
    exports.CollectionNameSchema = nonemptyString;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/configureIndex.js
var require_configureIndex = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/configureIndex.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.configureIndex = void 0;
    var errors_1 = require_errors();
    var validator_1 = require_validator();
    var typebox_1 = require_typebox();
    var types_1 = require_types2();
    var ConfigureIndexOptionsSchema = typebox_1.Type.Object({
      replicas: typebox_1.Type.Optional(types_1.ReplicasSchema),
      podType: typebox_1.Type.Optional(types_1.PodTypeSchema)
    }, { additionalProperties: false });
    var configureIndex = function(api) {
      var indexNameValidator = (0, validator_1.buildValidator)("The first argument to configureIndex", types_1.IndexNameSchema);
      var patchRequestValidator = (0, validator_1.buildValidator)("The second argument to configureIndex", ConfigureIndexOptionsSchema);
      return function(indexName, options) {
        return __awaiter(void 0, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                indexNameValidator(indexName);
                patchRequestValidator(options);
                if (Object.keys(options).length === 0) {
                  throw new errors_1.PineconeArgumentError("The second argument to configureIndex should not be empty object. Please specify at least one property (replicas, podType) to update.");
                }
                return [4, api.configureIndex({
                  indexName,
                  configureIndexRequest: { spec: { pod: options } }
                })];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
    };
    exports.configureIndex = configureIndex;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/createIndex.js
var require_createIndex = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/createIndex.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIndex = void 0;
    var validator_1 = require_validator();
    var utils_1 = require_utils();
    var errors_1 = require_errors();
    var typebox_1 = require_typebox();
    var types_1 = require_types2();
    var CreateIndexOptionsSchema = typebox_1.Type.Object({
      name: types_1.IndexNameSchema,
      dimension: types_1.DimensionSchema,
      metric: types_1.MetricSchema,
      spec: typebox_1.Type.Object({
        serverless: typebox_1.Type.Optional(typebox_1.Type.Object({
          cloud: types_1.CloudSchema,
          region: types_1.RegionSchema
        })),
        pod: typebox_1.Type.Optional(typebox_1.Type.Object({
          environment: types_1.EnvironmentSchema,
          replicas: typebox_1.Type.Optional(types_1.ReplicasSchema),
          shards: typebox_1.Type.Optional(types_1.ShardsSchema),
          podType: typebox_1.Type.Optional(types_1.PodTypeSchema),
          pods: typebox_1.Type.Optional(types_1.PodsSchema),
          metadataConfig: typebox_1.Type.Optional(types_1.MetadataConfigSchema),
          sourceCollection: typebox_1.Type.Optional(types_1.CollectionNameSchema)
        }))
      }),
      waitUntilReady: typebox_1.Type.Optional(typebox_1.Type.Boolean()),
      suppressConflicts: typebox_1.Type.Optional(typebox_1.Type.Boolean())
    }, { additionalProperties: false });
    var createIndex = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(CreateIndexOptionsSchema, "createIndex");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var createResponse, e_1;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (options && !options.metric) {
                  options.metric = "cosine";
                }
                validator(options);
                _a.label = 1;
              case 1:
                _a.trys.push([1, 5, , 6]);
                return [4, api.createIndex({
                  createIndexRequest: options
                })];
              case 2:
                createResponse = _a.sent();
                if (!options.waitUntilReady) return [3, 4];
                return [4, waitUntilIndexIsReady(api, options.name)];
              case 3:
                return [2, _a.sent()];
              case 4:
                return [2, createResponse];
              case 5:
                e_1 = _a.sent();
                if (!(options.suppressConflicts && e_1 instanceof Error && e_1.name === "PineconeConflictError")) {
                  throw e_1;
                }
                return [3, 6];
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.createIndex = createIndex;
    var waitUntilIndexIsReady = function(api, indexName, seconds) {
      if (seconds === void 0) {
        seconds = 0;
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var indexDescription, e_2, err;
        var _a;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 6, , 8]);
              return [4, api.describeIndex({ indexName })];
            case 1:
              indexDescription = _b.sent();
              if (!!((_a = indexDescription.status) === null || _a === void 0 ? void 0 : _a.ready)) return [3, 4];
              return [4, new Promise(function(r) {
                return setTimeout(r, 1e3);
              })];
            case 2:
              _b.sent();
              return [4, waitUntilIndexIsReady(api, indexName, seconds + 1)];
            case 3:
              return [2, _b.sent()];
            case 4:
              (0, utils_1.debugLog)("Index ".concat(indexName, " is ready after ").concat(seconds));
              return [2, indexDescription];
            case 5:
              return [3, 8];
            case 6:
              e_2 = _b.sent();
              return [4, (0, errors_1.handleApiError)(e_2, function(_, rawMessageText) {
                return __awaiter(void 0, void 0, void 0, function() {
                  return __generator(this, function(_a2) {
                    return [2, "Error creating index ".concat(indexName, ": ").concat(rawMessageText)];
                  });
                });
              })];
            case 7:
              err = _b.sent();
              throw err;
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/deleteIndex.js
var require_deleteIndex = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/deleteIndex.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteIndex = void 0;
    var validator_1 = require_validator();
    var types_1 = require_types2();
    var deleteIndex = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.IndexNameSchema, "deleteIndex");
      return function(indexName) {
        return __awaiter(void 0, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                validator(indexName);
                return [4, api.deleteIndex({ indexName })];
              case 1:
                _a.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteIndex = deleteIndex;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/describeIndex.js
var require_describeIndex = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/describeIndex.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.describeIndex = void 0;
    var validator_1 = require_validator();
    var types_1 = require_types2();
    var describeIndex = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.IndexNameSchema, "describeIndex");
      var removeDeprecatedFields = function(result) {
        if (result.database) {
          for (var _i = 0, _a = Object.keys(result.database); _i < _a.length; _i++) {
            var key = _a[_i];
            if (result.database[key] === void 0) {
              delete result.database[key];
            }
          }
        }
      };
      return function(indexName) {
        return __awaiter(void 0, void 0, void 0, function() {
          var result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                validator(indexName);
                return [4, api.describeIndex({ indexName })];
              case 1:
                result = _a.sent();
                removeDeprecatedFields(result);
                return [2, result];
            }
          });
        });
      };
    };
    exports.describeIndex = describeIndex;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/listIndexes.js
var require_listIndexes = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/listIndexes.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.listIndexes = void 0;
    var listIndexes = function(api) {
      return function() {
        return __awaiter(void 0, void 0, void 0, function() {
          var response;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, api.listIndexes()];
              case 1:
                response = _a.sent();
                return [2, response];
            }
          });
        });
      };
    };
    exports.listIndexes = listIndexes;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/createCollection.js
var require_createCollection = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/createCollection.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCollection = void 0;
    var validator_1 = require_validator();
    var types_1 = require_types2();
    var typebox_1 = require_typebox();
    var CreateCollectionOptionsSchema = typebox_1.Type.Object({
      name: types_1.CollectionNameSchema,
      source: types_1.IndexNameSchema
    }, { additionalProperties: false });
    var createCollection = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(CreateCollectionOptionsSchema, "createCollection");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                validator(options);
                return [4, api.createCollection({ createCollectionRequest: options })];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
    };
    exports.createCollection = createCollection;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/deleteCollection.js
var require_deleteCollection = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/deleteCollection.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteCollection = void 0;
    var validator_1 = require_validator();
    var types_1 = require_types2();
    var deleteCollection = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.CollectionNameSchema, "deleteCollection");
      return function(collectionName) {
        return __awaiter(void 0, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                validator(collectionName);
                return [4, api.deleteCollection({ collectionName })];
              case 1:
                _a.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteCollection = deleteCollection;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/describeCollection.js
var require_describeCollection = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/describeCollection.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.describeCollection = void 0;
    var validator_1 = require_validator();
    var types_1 = require_types2();
    var describeCollection = function(api) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.CollectionNameSchema, "describeCollection");
      return function(name) {
        return __awaiter(void 0, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                validator(name);
                return [4, api.describeCollection({ collectionName: name })];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
    };
    exports.describeCollection = describeCollection;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/listCollections.js
var require_listCollections = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/listCollections.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.listCollections = void 0;
    var listCollections = function(api) {
      return function() {
        return __awaiter(void 0, void 0, void 0, function() {
          var results;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, api.listCollections()];
              case 1:
                results = _a.sent();
                return [2, results];
            }
          });
        });
      };
    };
    exports.listCollections = listCollections;
  }
});

// node_modules/@pinecone-database/pinecone/dist/control/index.js
var require_control = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/control/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.listCollections = exports.describeCollection = exports.deleteCollection = exports.createCollection = exports.listIndexes = exports.describeIndex = exports.deleteIndex = exports.createIndex = exports.configureIndex = exports.indexOperationsBuilder = void 0;
    var indexOperationsBuilder_1 = require_indexOperationsBuilder();
    Object.defineProperty(exports, "indexOperationsBuilder", { enumerable: true, get: function() {
      return indexOperationsBuilder_1.indexOperationsBuilder;
    } });
    var configureIndex_1 = require_configureIndex();
    Object.defineProperty(exports, "configureIndex", { enumerable: true, get: function() {
      return configureIndex_1.configureIndex;
    } });
    var createIndex_1 = require_createIndex();
    Object.defineProperty(exports, "createIndex", { enumerable: true, get: function() {
      return createIndex_1.createIndex;
    } });
    var deleteIndex_1 = require_deleteIndex();
    Object.defineProperty(exports, "deleteIndex", { enumerable: true, get: function() {
      return deleteIndex_1.deleteIndex;
    } });
    var describeIndex_1 = require_describeIndex();
    Object.defineProperty(exports, "describeIndex", { enumerable: true, get: function() {
      return describeIndex_1.describeIndex;
    } });
    var listIndexes_1 = require_listIndexes();
    Object.defineProperty(exports, "listIndexes", { enumerable: true, get: function() {
      return listIndexes_1.listIndexes;
    } });
    var createCollection_1 = require_createCollection();
    Object.defineProperty(exports, "createCollection", { enumerable: true, get: function() {
      return createCollection_1.createCollection;
    } });
    var deleteCollection_1 = require_deleteCollection();
    Object.defineProperty(exports, "deleteCollection", { enumerable: true, get: function() {
      return deleteCollection_1.deleteCollection;
    } });
    var describeCollection_1 = require_describeCollection();
    Object.defineProperty(exports, "describeCollection", { enumerable: true, get: function() {
      return describeCollection_1.describeCollection;
    } });
    var listCollections_1 = require_listCollections();
    Object.defineProperty(exports, "listCollections", { enumerable: true, get: function() {
      return listCollections_1.listCollections;
    } });
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/indexHostSingleton.js
var require_indexHostSingleton = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/indexHostSingleton.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IndexHostSingleton = void 0;
    var control_1 = require_control();
    var errors_1 = require_errors();
    var utils_1 = require_utils();
    exports.IndexHostSingleton = /* @__PURE__ */ function() {
      var _this = this;
      var hostUrls = {};
      var _describeIndex = function(config, indexName) {
        return __awaiter(_this, void 0, void 0, function() {
          var indexOperationsApi, describeResponse, host;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                indexOperationsApi = (0, control_1.indexOperationsBuilder)(config);
                return [4, (0, control_1.describeIndex)(indexOperationsApi)(indexName)];
              case 1:
                describeResponse = _a.sent();
                host = describeResponse.host;
                if (!host) {
                  throw new errors_1.PineconeUnableToResolveHostError("The HTTP call succeeded but the host URL could not be resolved. Please make sure the index exists and is in a ready state.");
                } else {
                  return [2, host];
                }
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      var _key = function(config, indexName) {
        return "".concat(config.apiKey, "-").concat(indexName);
      };
      var singleton = {
        getHostUrl: function(config, indexName) {
          return __awaiter(_this, void 0, void 0, function() {
            var cacheKey, hostUrl;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  cacheKey = _key(config, indexName);
                  if (!(cacheKey in hostUrls)) return [3, 1];
                  return [2, hostUrls[cacheKey]];
                case 1:
                  return [4, _describeIndex(config, indexName)];
                case 2:
                  hostUrl = _a.sent();
                  singleton._set(config, indexName, hostUrl);
                  if (!hostUrls[cacheKey]) {
                    throw new errors_1.PineconeUnableToResolveHostError("Could not get host for index: ".concat(indexName, ". Call describeIndex('").concat(indexName, "') to check the current status."));
                  }
                  return [2, hostUrls[cacheKey]];
              }
            });
          });
        },
        _reset: function() {
          for (var _i = 0, _a = Object.keys(hostUrls); _i < _a.length; _i++) {
            var key = _a[_i];
            delete hostUrls[key];
          }
        },
        _set: function(config, indexName, hostUrl) {
          var normalizedHostUrl = (0, utils_1.normalizeUrl)(hostUrl);
          if (!normalizedHostUrl) {
            return;
          }
          var cacheKey = _key(config, indexName);
          hostUrls[cacheKey] = normalizedHostUrl;
        },
        _delete: function(config, indexName) {
          var cacheKey = _key(config, indexName);
          delete hostUrls[cacheKey];
        }
      };
      return singleton;
    }();
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/types.js
var require_types3 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PineconeRecordSchema = exports.RecordSparseValuesSchema = exports.RecordValuesSchema = exports.RecordIdSchema = exports.PineconeConfigurationSchema = void 0;
    var typebox_1 = require_typebox();
    exports.PineconeConfigurationSchema = typebox_1.Type.Object({
      apiKey: typebox_1.Type.String({ minLength: 1 }),
      controllerHostUrl: typebox_1.Type.Optional(typebox_1.Type.String({ minLength: 1 })),
      // fetchApi is a complex type that I don't really want to recreate in the
      // form of a json schema (seems difficult and error prone). So we will
      // rely on TypeScript to guide people in the right direction here.
      // But declaring it here as Type.Any() is needed to avoid getting caught
      // in the additionalProperties check.
      fetchApi: typebox_1.Type.Optional(typebox_1.Type.Any()),
      additionalHeaders: typebox_1.Type.Optional(typebox_1.Type.Any()),
      sourceTag: typebox_1.Type.Optional(typebox_1.Type.String({ minLength: 1 }))
    }, { additionalProperties: false });
    exports.RecordIdSchema = typebox_1.Type.String({ minLength: 1 });
    exports.RecordValuesSchema = typebox_1.Type.Array(typebox_1.Type.Number());
    exports.RecordSparseValuesSchema = typebox_1.Type.Object({
      indices: typebox_1.Type.Array(typebox_1.Type.Integer()),
      values: typebox_1.Type.Array(typebox_1.Type.Number())
    }, { additionalProperties: false });
    exports.PineconeRecordSchema = typebox_1.Type.Object({
      id: exports.RecordIdSchema,
      values: exports.RecordValuesSchema,
      sparseValues: typebox_1.Type.Optional(exports.RecordSparseValuesSchema),
      metadata: typebox_1.Type.Optional(typebox_1.Type.Object({}, { additionalProperties: true }))
    }, { additionalProperties: false });
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/upsert.js
var require_upsert = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/upsert.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpsertCommand = void 0;
    var validator_1 = require_validator();
    var types_1 = require_types3();
    var typebox_1 = require_typebox();
    var RecordArray = typebox_1.Type.Array(types_1.PineconeRecordSchema);
    var UpsertCommand = (
      /** @class */
      function() {
        function UpsertCommand2(apiProvider, namespace) {
          this.apiProvider = apiProvider;
          this.namespace = namespace;
          this.validator = (0, validator_1.buildConfigValidator)(RecordArray, "upsert");
        }
        UpsertCommand2.prototype.run = function(records) {
          return __awaiter(this, void 0, void 0, function() {
            var api;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  this.validator(records);
                  return [4, this.apiProvider.provide()];
                case 1:
                  api = _a.sent();
                  return [4, api.upsert({
                    upsertRequest: {
                      vectors: records,
                      namespace: this.namespace
                    }
                  })];
                case 2:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return UpsertCommand2;
      }()
    );
    exports.UpsertCommand = UpsertCommand;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/fetch.js
var require_fetch2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/fetch.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchCommand = void 0;
    var validator_1 = require_validator();
    var types_1 = require_types3();
    var typebox_1 = require_typebox();
    var RecordIdsArray = typebox_1.Type.Array(types_1.RecordIdSchema, { minItems: 1 });
    var FetchCommand = (
      /** @class */
      function() {
        function FetchCommand2(apiProvider, namespace) {
          this.apiProvider = apiProvider;
          this.namespace = namespace;
          this.validator = (0, validator_1.buildConfigValidator)(RecordIdsArray, "fetch");
        }
        FetchCommand2.prototype.run = function(ids) {
          return __awaiter(this, void 0, void 0, function() {
            var api, response;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  this.validator(ids);
                  return [4, this.apiProvider.provide()];
                case 1:
                  api = _a.sent();
                  return [4, api.fetch({ ids, namespace: this.namespace })];
                case 2:
                  response = _a.sent();
                  return [2, __assign({ records: response.vectors ? response.vectors : {}, namespace: response.namespace ? response.namespace : "" }, response.usage && { usage: response.usage })];
              }
            });
          });
        };
        return FetchCommand2;
      }()
    );
    exports.FetchCommand = FetchCommand;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/update.js
var require_update = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/update.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateCommand = void 0;
    var validator_1 = require_validator();
    var typebox_1 = require_typebox();
    var types_1 = require_types3();
    var UpdateRecordOptionsSchema = typebox_1.Type.Object({
      id: types_1.RecordIdSchema,
      values: typebox_1.Type.Optional(types_1.RecordValuesSchema),
      sparseValues: typebox_1.Type.Optional(types_1.RecordSparseValuesSchema),
      metadata: typebox_1.Type.Optional(typebox_1.Type.Object({}, { additionalProperties: true }))
    }, { additionalProperties: false });
    var UpdateCommand = (
      /** @class */
      function() {
        function UpdateCommand2(apiProvider, namespace) {
          this.apiProvider = apiProvider;
          this.namespace = namespace;
          this.validator = (0, validator_1.buildConfigValidator)(UpdateRecordOptionsSchema, "update");
        }
        UpdateCommand2.prototype.run = function(options) {
          return __awaiter(this, void 0, void 0, function() {
            var requestOptions, api;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  this.validator(options);
                  requestOptions = {
                    id: options["id"],
                    values: options["values"],
                    sparseValues: options["sparseValues"],
                    setMetadata: options["metadata"]
                  };
                  return [4, this.apiProvider.provide()];
                case 1:
                  api = _a.sent();
                  return [4, api.update({
                    updateRequest: __assign(__assign({}, requestOptions), { namespace: this.namespace })
                  })];
                case 2:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return UpdateCommand2;
      }()
    );
    exports.UpdateCommand = UpdateCommand;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/query.js
var require_query = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/query.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryCommand = void 0;
    var validator_1 = require_validator();
    var types_1 = require_types3();
    var typebox_1 = require_typebox();
    var shared = {
      topK: typebox_1.Type.Number(),
      includeValues: typebox_1.Type.Optional(typebox_1.Type.Boolean()),
      includeMetadata: typebox_1.Type.Optional(typebox_1.Type.Boolean()),
      filter: typebox_1.Type.Optional(typebox_1.Type.Object({}))
    };
    var QueryByRecordId = typebox_1.Type.Object(__assign(__assign({}, shared), { id: types_1.RecordIdSchema, vector: typebox_1.Type.Optional(typebox_1.Type.Never()), sparseVector: typebox_1.Type.Optional(typebox_1.Type.Never()) }), { additionalProperties: false });
    var QueryByVectorValues = typebox_1.Type.Object(__assign(__assign({}, shared), { vector: types_1.RecordValuesSchema, sparseVector: typebox_1.Type.Optional(types_1.RecordSparseValuesSchema), id: typebox_1.Type.Optional(typebox_1.Type.Never()) }), { additionalProperties: false });
    var QuerySchema = typebox_1.Type.Union([QueryByRecordId, QueryByVectorValues]);
    var QueryCommand = (
      /** @class */
      function() {
        function QueryCommand2(apiProvider, namespace) {
          this.apiProvider = apiProvider;
          this.namespace = namespace;
          this.validator = (0, validator_1.buildConfigValidator)(QuerySchema, "query");
        }
        QueryCommand2.prototype.run = function(query) {
          return __awaiter(this, void 0, void 0, function() {
            var api, results, matches;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  this.validator(query);
                  return [4, this.apiProvider.provide()];
                case 1:
                  api = _a.sent();
                  return [4, api.query({
                    queryRequest: __assign(__assign({}, query), { namespace: this.namespace })
                  })];
                case 2:
                  results = _a.sent();
                  matches = results.matches ? results.matches : [];
                  return [2, __assign({ matches, namespace: this.namespace }, results.usage && { usage: results.usage })];
              }
            });
          });
        };
        return QueryCommand2;
      }()
    );
    exports.QueryCommand = QueryCommand;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/deleteOne.js
var require_deleteOne = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/deleteOne.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteOne = void 0;
    var validator_1 = require_validator();
    var types_1 = require_types3();
    var deleteOne = function(apiProvider, namespace) {
      var validator = (0, validator_1.buildConfigValidator)(types_1.RecordIdSchema, "deleteOne");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var api;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                validator(options);
                return [4, apiProvider.provide()];
              case 1:
                api = _a.sent();
                return [4, api._delete({ deleteRequest: { ids: [options], namespace } })];
              case 2:
                _a.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteOne = deleteOne;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/deleteMany.js
var require_deleteMany = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/deleteMany.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteMany = void 0;
    var validator_1 = require_validator();
    var typebox_1 = require_typebox();
    var types_1 = require_types3();
    var DeleteManyByRecordIdSchema = typebox_1.Type.Array(types_1.RecordIdSchema);
    var DeleteManyByFilterSchema = typebox_1.Type.Object({}, { additionalProperties: true, minProperties: 1 });
    var DeleteManySchema = typebox_1.Type.Union([
      DeleteManyByRecordIdSchema,
      DeleteManyByFilterSchema
    ]);
    var deleteMany = function(apiProvider, namespace) {
      var validator = (0, validator_1.buildConfigValidator)(DeleteManySchema, "deleteMany");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var requestOptions, api;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                validator(options);
                requestOptions = {};
                if (Array.isArray(options)) {
                  requestOptions.ids = options;
                } else {
                  requestOptions.filter = options;
                }
                return [4, apiProvider.provide()];
              case 1:
                api = _a.sent();
                return [4, api._delete({ deleteRequest: __assign(__assign({}, requestOptions), { namespace }) })];
              case 2:
                _a.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteMany = deleteMany;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/deleteAll.js
var require_deleteAll = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/deleteAll.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteAll = void 0;
    var deleteAll = function(apiProvider, namespace) {
      return function() {
        return __awaiter(void 0, void 0, void 0, function() {
          var api;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, apiProvider.provide()];
              case 1:
                api = _a.sent();
                return [4, api._delete({ deleteRequest: { deleteAll: true, namespace } })];
              case 2:
                _a.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    exports.deleteAll = deleteAll;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/describeIndexStats.js
var require_describeIndexStats = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/describeIndexStats.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.describeIndexStats = void 0;
    var validator_1 = require_validator();
    var typebox_1 = require_typebox();
    var DescribeIndexStatsOptionsSchema = typebox_1.Type.Object({
      filter: typebox_1.Type.Optional(typebox_1.Type.Object({}, { additionalProperties: true }))
    }, { additionalProperties: false });
    var describeIndexStats = function(apiProvider) {
      var validator = (0, validator_1.buildConfigValidator)(DescribeIndexStatsOptionsSchema, "describeIndexStats");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var api, results, mappedResult, key;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (options) {
                  validator(options);
                }
                return [4, apiProvider.provide()];
              case 1:
                api = _a.sent();
                return [4, api.describeIndexStats({
                  describeIndexStatsRequest: __assign({}, options)
                })];
              case 2:
                results = _a.sent();
                mappedResult = {
                  namespaces: {},
                  dimension: results.dimension,
                  indexFullness: results.indexFullness,
                  totalRecordCount: results.totalVectorCount
                };
                if (results.namespaces) {
                  for (key in results.namespaces) {
                    mappedResult.namespaces[key] = {
                      recordCount: results.namespaces[key].vectorCount
                    };
                  }
                }
                return [2, mappedResult];
            }
          });
        });
      };
    };
    exports.describeIndexStats = describeIndexStats;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/dataOperationsProvider.js
var require_dataOperationsProvider = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/dataOperationsProvider.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataOperationsProvider = void 0;
    var pinecone_generated_ts_fetch_1 = require_pinecone_generated_ts_fetch();
    var utils_1 = require_utils();
    var indexHostSingleton_1 = require_indexHostSingleton();
    var middleware_1 = require_middleware();
    var DataOperationsProvider = (
      /** @class */
      function() {
        function DataOperationsProvider2(config, indexName, indexHostUrl, additionalHeaders) {
          this.config = config;
          this.indexName = indexName;
          this.indexHostUrl = (0, utils_1.normalizeUrl)(indexHostUrl);
          this.additionalHeaders = additionalHeaders;
        }
        DataOperationsProvider2.prototype.provide = function() {
          return __awaiter(this, void 0, void 0, function() {
            var _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (this.dataOperations) {
                    return [2, this.dataOperations];
                  }
                  if (!this.indexHostUrl) return [3, 1];
                  this.dataOperations = this.buildDataOperationsConfig();
                  return [3, 3];
                case 1:
                  _a = this;
                  return [4, indexHostSingleton_1.IndexHostSingleton.getHostUrl(this.config, this.indexName)];
                case 2:
                  _a.indexHostUrl = _b.sent();
                  this.dataOperations = this.buildDataOperationsConfig();
                  _b.label = 3;
                case 3:
                  return [2, this.dataOperations];
              }
            });
          });
        };
        DataOperationsProvider2.prototype.buildDataOperationsConfig = function() {
          var headers = this.additionalHeaders || null;
          var indexConfigurationParameters = {
            basePath: this.indexHostUrl,
            apiKey: this.config.apiKey,
            queryParamsStringify: utils_1.queryParamsStringify,
            headers: __assign({ "User-Agent": (0, utils_1.buildUserAgent)(this.config) }, headers),
            fetchApi: (0, utils_1.getFetch)(this.config),
            middleware: middleware_1.middleware
          };
          var indexConfiguration = new pinecone_generated_ts_fetch_1.Configuration(indexConfigurationParameters);
          var dataOperations = new pinecone_generated_ts_fetch_1.DataPlaneApi(indexConfiguration);
          return dataOperations;
        };
        return DataOperationsProvider2;
      }()
    );
    exports.DataOperationsProvider = DataOperationsProvider;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/list.js
var require_list = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/list.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.listPaginated = void 0;
    var validator_1 = require_validator();
    var typebox_1 = require_typebox();
    var ListOptionsSchema = typebox_1.Type.Object({
      prefix: typebox_1.Type.Optional(typebox_1.Type.String({ minLength: 1 })),
      limit: typebox_1.Type.Optional(typebox_1.Type.Number()),
      paginationToken: typebox_1.Type.Optional(typebox_1.Type.String({ minLength: 1 }))
    }, { additionalProperties: false });
    var listPaginated = function(apiProvider, namespace) {
      var validator = (0, validator_1.buildConfigValidator)(ListOptionsSchema, "listPaginated");
      return function(options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var listRequest, api;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (options) {
                  validator(options);
                }
                listRequest = __assign(__assign({}, options), { namespace });
                return [4, apiProvider.provide()];
              case 1:
                api = _a.sent();
                return [4, api.list(listRequest)];
              case 2:
                return [2, _a.sent()];
            }
          });
        });
      };
    };
    exports.listPaginated = listPaginated;
  }
});

// node_modules/@pinecone-database/pinecone/dist/data/index.js
var require_data2 = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/data/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Index = exports.PineconeConfigurationSchema = void 0;
    var upsert_1 = require_upsert();
    var fetch_1 = require_fetch2();
    var update_1 = require_update();
    var query_1 = require_query();
    var deleteOne_1 = require_deleteOne();
    var deleteMany_1 = require_deleteMany();
    var deleteAll_1 = require_deleteAll();
    var describeIndexStats_1 = require_describeIndexStats();
    var dataOperationsProvider_1 = require_dataOperationsProvider();
    var list_1 = require_list();
    var types_1 = require_types3();
    Object.defineProperty(exports, "PineconeConfigurationSchema", { enumerable: true, get: function() {
      return types_1.PineconeConfigurationSchema;
    } });
    var Index = (
      /** @class */
      function() {
        function Index2(indexName, config, namespace, indexHostUrl, additionalHeaders) {
          if (namespace === void 0) {
            namespace = "";
          }
          this.config = config;
          this.target = {
            index: indexName,
            namespace,
            indexHostUrl
          };
          var apiProvider = new dataOperationsProvider_1.DataOperationsProvider(config, indexName, indexHostUrl, additionalHeaders);
          this._deleteAll = (0, deleteAll_1.deleteAll)(apiProvider, namespace);
          this._deleteMany = (0, deleteMany_1.deleteMany)(apiProvider, namespace);
          this._deleteOne = (0, deleteOne_1.deleteOne)(apiProvider, namespace);
          this._describeIndexStats = (0, describeIndexStats_1.describeIndexStats)(apiProvider);
          this._listPaginated = (0, list_1.listPaginated)(apiProvider, namespace);
          this._fetchCommand = new fetch_1.FetchCommand(apiProvider, namespace);
          this._queryCommand = new query_1.QueryCommand(apiProvider, namespace);
          this._updateCommand = new update_1.UpdateCommand(apiProvider, namespace);
          this._upsertCommand = new upsert_1.UpsertCommand(apiProvider, namespace);
        }
        Index2.prototype.deleteAll = function() {
          return this._deleteAll();
        };
        Index2.prototype.deleteMany = function(options) {
          return this._deleteMany(options);
        };
        Index2.prototype.deleteOne = function(id) {
          return this._deleteOne(id);
        };
        Index2.prototype.describeIndexStats = function() {
          return this._describeIndexStats();
        };
        Index2.prototype.listPaginated = function(options) {
          return this._listPaginated(options);
        };
        Index2.prototype.namespace = function(namespace) {
          return new Index2(this.target.index, this.config, namespace, this.target.indexHostUrl);
        };
        Index2.prototype.upsert = function(data) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this._upsertCommand.run(data)];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        Index2.prototype.fetch = function(options) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this._fetchCommand.run(options)];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        Index2.prototype.query = function(options) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this._queryCommand.run(options)];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        Index2.prototype.update = function(options) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this._updateCommand.run(options)];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        return Index2;
      }()
    );
    exports.Index = Index;
  }
});

// node_modules/@pinecone-database/pinecone/dist/pinecone.js
var require_pinecone = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/pinecone.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pinecone = void 0;
    var control_1 = require_control();
    var indexHostSingleton_1 = require_indexHostSingleton();
    var errors_1 = require_errors();
    var data_1 = require_data2();
    var validator_1 = require_validator();
    var Pinecone = (
      /** @class */
      function() {
        function Pinecone2(options) {
          if (options === void 0) {
            options = this._readEnvironmentConfig();
          }
          this._validateConfig(options);
          this.config = options;
          var api = (0, control_1.indexOperationsBuilder)(this.config);
          this._configureIndex = (0, control_1.configureIndex)(api);
          this._createCollection = (0, control_1.createCollection)(api);
          this._createIndex = (0, control_1.createIndex)(api);
          this._describeCollection = (0, control_1.describeCollection)(api);
          this._deleteCollection = (0, control_1.deleteCollection)(api);
          this._describeIndex = (0, control_1.describeIndex)(api);
          this._deleteIndex = (0, control_1.deleteIndex)(api);
          this._listCollections = (0, control_1.listCollections)(api);
          this._listIndexes = (0, control_1.listIndexes)(api);
        }
        Pinecone2.prototype._readEnvironmentConfig = function() {
          if (typeof process === "undefined" || !process || !process.env) {
            throw new errors_1.PineconeEnvironmentVarsNotSupportedError("Your execution environment does not support reading environment variables from process.env, so a configuration object is required when calling new Pinecone()");
          }
          var environmentConfig = {};
          var requiredEnvVarMap = {
            apiKey: "PINECONE_API_KEY"
          };
          var missingVars = [];
          for (var _i = 0, _a = Object.entries(requiredEnvVarMap); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], envVar = _b[1];
            var value = process.env[envVar] || "";
            if (!value) {
              missingVars.push(envVar);
            }
            environmentConfig[key] = value;
          }
          if (missingVars.length > 0) {
            throw new errors_1.PineconeConfigurationError("Since you called 'new Pinecone()' with no configuration object, we attempted to find client configuration in environment variables but the required environment variables were not set. Missing variables: ".concat(missingVars.join(", "), "."));
          }
          var optionalEnvVarMap = {
            controllerHostUrl: "PINECONE_CONTROLLER_HOST"
          };
          for (var _c = 0, _d = Object.entries(optionalEnvVarMap); _c < _d.length; _c++) {
            var _e = _d[_c], key = _e[0], envVar = _e[1];
            var value = process.env[envVar];
            if (value !== void 0) {
              environmentConfig[key] = value;
            }
          }
          return environmentConfig;
        };
        Pinecone2.prototype.describeIndex = function(indexName) {
          return __awaiter(this, void 0, void 0, function() {
            var indexModel;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this._describeIndex(indexName)];
                case 1:
                  indexModel = _a.sent();
                  if (indexModel.host) {
                    indexHostSingleton_1.IndexHostSingleton._set(this.config, indexName, indexModel.host);
                  }
                  return [2, Promise.resolve(indexModel)];
              }
            });
          });
        };
        Pinecone2.prototype.listIndexes = function() {
          return __awaiter(this, void 0, void 0, function() {
            var indexList, i, index;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this._listIndexes()];
                case 1:
                  indexList = _a.sent();
                  if (indexList.indexes && indexList.indexes.length > 0) {
                    for (i = 0; i < indexList.indexes.length; i++) {
                      index = indexList.indexes[i];
                      indexHostSingleton_1.IndexHostSingleton._set(this.config, index.name, index.host);
                    }
                  }
                  return [2, Promise.resolve(indexList)];
              }
            });
          });
        };
        Pinecone2.prototype.createIndex = function(options) {
          return this._createIndex(options);
        };
        Pinecone2.prototype.deleteIndex = function(indexName) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this._deleteIndex(indexName)];
                case 1:
                  _a.sent();
                  indexHostSingleton_1.IndexHostSingleton._delete(this.config, indexName);
                  return [2, Promise.resolve()];
              }
            });
          });
        };
        Pinecone2.prototype.configureIndex = function(indexName, options) {
          return this._configureIndex(indexName, options);
        };
        Pinecone2.prototype.createCollection = function(options) {
          return this._createCollection(options);
        };
        Pinecone2.prototype.listCollections = function() {
          return this._listCollections();
        };
        Pinecone2.prototype.deleteCollection = function(collectionName) {
          return this._deleteCollection(collectionName);
        };
        Pinecone2.prototype.describeCollection = function(collectionName) {
          return this._describeCollection(collectionName);
        };
        Pinecone2.prototype._validateConfig = function(options) {
          (0, validator_1.buildValidator)("The client configuration", data_1.PineconeConfigurationSchema)(options);
        };
        Pinecone2.prototype.getConfig = function() {
          return this.config;
        };
        Pinecone2.prototype.index = function(indexName, indexHostUrl, additionalHeaders) {
          return new data_1.Index(indexName, this.config, void 0, indexHostUrl, additionalHeaders);
        };
        Pinecone2.prototype.Index = function(indexName, indexHostUrl, additionalHeaders) {
          return this.index(indexName, indexHostUrl, additionalHeaders);
        };
        return Pinecone2;
      }()
    );
    exports.Pinecone = Pinecone;
  }
});

// node_modules/@pinecone-database/pinecone/dist/index.js
var require_dist = __commonJS({
  "node_modules/@pinecone-database/pinecone/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Errors = exports.Index = exports.Pinecone = void 0;
    var pinecone_1 = require_pinecone();
    Object.defineProperty(exports, "Pinecone", { enumerable: true, get: function() {
      return pinecone_1.Pinecone;
    } });
    var data_1 = require_data2();
    Object.defineProperty(exports, "Index", { enumerable: true, get: function() {
      return data_1.Index;
    } });
    exports.Errors = __importStar(require_errors());
  }
});
export default require_dist();
//# sourceMappingURL=@pinecone-database_pinecone.js.map
